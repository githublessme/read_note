java虚拟机运行时数据区：
	1.程序计数器：
		用来记录当前线程执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条要执行的字节码命令。

		java虚拟机的多线程是通过线程的轮流切换来实现的，所以每个线程都要记录自己线程对应的执行到的字节码行数，来确保当本线程取得了执行的权利之后可以从上次
		中断的位置继续执行。所以程序计数器是线程私有的，每个线程都有一个独立的程序计数器。
		
		注意：如果线程执行的是java方法则程序计数器存储的是字节码的行号，而如果执行的是native方法,则计数器为空。此内存区是唯一一个在java虚拟机规范中没有规定
		      任何OutOfMemoryError情况的区域。
	
	2.java虚拟机栈：
		和程序计数器一样也是线程私有的，生命周期和线程相同。每个方法执行的时候都会创建一个栈帧（stackFrame），用来储存局部变量表，操作栈、动态链接、方法出口
		等信息。每一个方法的调用直到执行结束就对应着栈帧在java虚拟机栈的从入栈到出栈的过程。

		现在许多程序员喜欢笼统的说堆栈，这其中的栈就是对应的java虚拟机栈中的局部变量表的部分。

		局部变量表存储着各种基本类型的变量（boolean，int，short，long，double，float，byte，char）和对象的引用类型（可能是对象地址的指针，也可能指向对象的句
		柄，和returnAdress类型（1.7之后好像没什么卵用了））。

		其中64位的double和long类型的数据会占用两个变量空间（slot），其他的都占用一个。局部变量表所需的空间在编译期间来分配（很关键），在运行期间不会改变局部
		变量表的大小。

		java虚拟机规范中，规定了这个区域的两种异常情况：
			1.如果线程请求的栈深度大于虚拟机所允许的深度，跑出StackOverflowError异常。
			2.如果虚拟机可以扩展，当扩展申请不到足够的内存，抛出OutOfMemoryError异常。

	
	3.本地方法栈：
		本地方法栈和java虚拟机方法栈功能类似，区别就是本地方法栈是为native方法服务的，而java虚拟机栈是为执行java方法（字节码）服务的。

	4.java堆：
		Java堆是线程共享的，在虚拟机启动的时候创建。此内存区域唯一的目的就是存放对象实例。

		java堆是垃圾收集器集中管理的主要区域。现在的收集器基本都采用分代回收算法，将堆分为年轻代和老年代（young generation and old generation）。再细致一点
		可以分成Eden空间、From Survivor空间和 To Survivor空间等。
		如果从内存分配的角度来看，java堆中还可能划分出多个线程私有的分配缓存区(Thread Local Allocation Buffer)

		主流的虚拟机都是可扩展的（通过-Xmx 和-Xms 控制），当java堆没有内存完成实例分配并且无法扩展，抛出OutOfMemoryError异常。

	5.方法区：
		和java堆一样是各个线程共享的内存区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

		有些在hotspot虚拟机的开发的开发者喜欢把方法区成为永久代（Permanent Generation），知识hotspot团队将GC扩展到方法区，对于其他虚拟机（BEA JRockit、IBM J9）
		是不存在方法区的概念的。

		垃圾回收的行为在这个区域还是比价少见的，但并非数据进入这个区域后，就如同这个区域的名字一样永久存在了。这个区域内存回收的目标主要是针对常量池的回收和类型
		卸载。

		当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

	6.运行时常量池：
		