1.java中整形默认是int 浮点型默认是double，所以 float f=1.1;  int i=3.0  都是需要强转的。   float正确的定义格式为 float f=0.1f; 要用f来告诉java这个是float类型的小数
2.多线程：java中使用wait必须捕捉异常 而且调用wait或notify方法必须采用当前锁调用,即必须采用synchronized中的对象
3.Java标识符由数字、字母、下划线(_)、美元符号($)或人民币(¥)组成，首位不能是数字。并且Java关键字不能作为标识符。
4.java方法覆盖原则：
	方法的重写（override）两同两小一大原则：
	方法名相同，参数类型相同
	子类返回类型小于等于父类方法返回类型，
	子类抛出异常小于等于父类方法抛出异常，
	子类访问权限大于等于父类方法访问权限。
5.java中abstract：
	含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。
	含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。
	abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。
	如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
6.java中inteface：
	变量都是 public static final 的，方法都是 public abstract的
	java8之后，interface中可以定义 default 方法和static 方法，static 方法只能通过接口名调用，不能通过实现类名调用。default方法只能通过接口实例调用，并且可以在实现类中覆盖。
		两个接口拥有相同的static方法没关系，可以通过接口类名区分。但是拥有两个相同的default方法就必须在实现类中覆盖这个方法，否则编译器报错。

7.java的异常结构：
				Throwable
				/       \
			    Exception   Error
		    程序可处理异常      (非检查异常）
					程序无法处理的错误
					OutofMemoryError
					stackoverflowError
		    /	       \	
	   非检查异常   	    非运行时异常
	   RuntimeExcepion  	    检查异常
	   NullPointerException     IOException
ArrayIndexOutofBoundsException      EOFEception
ArithmeticException		    FileNotFoundException
NumberFormatException		    SQLExcpetion


8.java线程：
	run是线程执行的方法。
	start是启动线程对象，使之从新建状态转入就绪状态；
	sleep让线程睡眠一段时间，在此期间线程不消耗CPU资源；
	suspend使线程挂起，暂停执行， 如果想恢复线程，必须由其他线程调用 resume方法。
9.java中byte：
	byte b1=1,b2=2,b3;
	b3=(b1+b2)   是错误的，因为在计算时，byte会被转换为int类型进行计算，在计算完应该使用强转  正确格式：b3=(byte)(b1+b2);
	但是当变量是final类型就不会在计算时进行类型转换。
	例如：final byte b4=4,b5=5;  b3=b4+b5;
10.java中线程安全类：简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration

11.java中加载器：
	1）Bootstrap ClassLoader引导类加载器，加载java的核心库，使用原生代码实现的
 
	负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

	2）system class loader 系统类加载器，根据java应用的类路径（classpath）来加载类
 
	2）Extension ClassLoader扩展类加载器，加载java的扩展库
 
	负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
 
	3）App ClassLoader，tomcat为每个APP创建一个loader,里面保存着此webapp的classloader。需加载webapp下的类时，就取出classloader来使用。
 
	负责记载classpath中指定的jar包及目录中class
 
	4）Custom ClassLoader
 
	属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader
 
	加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，
	只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

12.java的参数传递：
	class Value{
		public int i=15;
	}
	public class Test{
		public static void main(String argv[]){
			Test t=new Test( );
			t.first( );
		}
 
		public void first( ){
			int i=5;
			Value v=new Value( );
			v.i=25;
			second(v,i);
			System.out.println(v.i);
		}
 
		public void second(Value v,int i){
			i = 0;
			v.i = 20;
			Value val = new Value( );
			v = val;
			System.out.println(v.i+" "+i);
		}
	}

	输出顺序 15 0 20

13.java中多线程：
	Java中的多线程是一种抢占式的机制，而不是分时机制。抢占式的机制是有多个线程处于可运行状态，但是只有一个线程在运行。 
	共同点 ： 
		1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 
		2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
		如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，
		则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 
		需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，
		如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，
		就会立刻抛出InterruptedException 。 
	不同点 ：  
		1.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 
		sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 
		2.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
		3.sleep，wait,join必须捕获异常，而notify和notifyAll不需要捕获异常 
		4.sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
		5.wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁,只有针对此对象发出notify方法（或notifyAll）后
		本线程才进入对象锁定池准备获得对象锁进入运行状态。

14.java的字符码集：
	java使用的是Unicode字符码，ASCII是国际使用最广泛的字符编码，BCD是一种数字压缩存储编码。Unicode中无论什么字符都是两个字节。

15.java中变量的范围：
	short -2^15  2^15-1
	int   -2^31  2^31-1
	long  -2^63  2^63-1
	float  -2^31  2^31-1
	double -2^63  2^63-1
	boolean 默认false

16.使用泛型取代非泛型的数据类型，程序的运行性能不会更好，因为java在编译阶段，虚拟机就会把泛型擦除，还原成没有泛型的代码，顶多编译时候慢点，运行时没有任何区别。
17.java中spring：
	Spring 框架是一个分层架构！！！由 7 个定义良好的模块组成。
	核心容器，Spring上下文，Spring AOP， Spring DAO， Spring ORM， Spring Web， Spring MVC。这些都是spring包含的框架

17.java的finalize：
	只有当没有引用指向这个对象的时候，垃圾回收器要回收这个对象时，才会调用这个方法。

18.java中的关键字
	1，Java 关键字列表 (依字母排序 共50组)：
		abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）,
		continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, 
		if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, 
		return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
	2，保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：
		byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null

	true和false是boolean类型的变量，是编译器赋予特殊含义的，但并不是关键字。

19.截至jdk1.8，java并发框架支持的锁：
	读写锁、自旋锁、乐观锁。

20.java多线程：
	synchronized 关键字 : 用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。
	volatile：用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，
		  因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，
		  因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。
	
21.java中join的作用：
	等待调用join的线程执行完才执行当前线程。

22.java中collection的继承结构：
	看图

23.java中字符串（重点）
	String str1="hello";
	String str2="he"+"llo";
	str1==str2  //true
	因为str1和str2都是常量，当java字符串常量池中存在hello时，str不会再生成一个新的字符串存到常量池，而是直接在常量池取"hello",所以实际上str1和str2指向同一个对象。
	
	String str1="hello";
	String str2="he"+new String("llo");
	str1==str2  //false
	因为str1声明后，java将"hello"存在字符串常量池中，str2在声明时并不知道str2的内容是什么，所以不会放到字符串常量池中，而是放在堆中存储。

24.java国际化：
	实现国际化的常用手段是利用ResourceBundle类

25.面向对象编程语言核心：
	封装、继承、多态
26.java中集合：
	hashMap 允许key和value都可以为null
	hashtable 不允许key和value为null

27.object中含有的默认方法：
	getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),  wait(), finalize()

28.java中堆的分配：
	-Xmx：最大堆大小
	-Xms：初始堆大小
	-Xmn:年轻代大小
	-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
	年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。
	-Xms初始堆大小即最小内存值为10240m

29.java中的编译问题:
	J2SDK是编程工具，不是API.
	Appletviewer.exe 就是用来解释执行java applet应用程序的,简单理解就是没有main函数的继承applet类的java类。
	能被Appletviewer成功运行的java class文件没有main()方法

30.java中多线程：
	CyclicBarrier和count DownLatch都可以让一组线程等待其他线程。
	Callable 中的call（）方法可以返回值和跑出异常（checkedException）

31.java中的初始化顺序：
	初始化父类中的静态成员和静态代码快，初始化子类中的静态成员和静态代码块。初始化父类中普通成员变量和代码块，再执行父类中的构造方法。初始化子类中的普通成员变量
	和代码块，再执行子类中的构造方法。

32.java中的标准statement
	1.statement是最基本的用法，采用字符串拼接的方法，存在sql注入漏洞。
	2.preparedstatement对statement中的sql语句进行预编译，同时检查合法性，效率高。
	3.CallableStatement接口扩展PreparedStatement，用来调用存储过程，它提供了对输入和输出参数的支持，CallableStatement接口还具有对PreparedStatement接口提供的输入
	  输出的参数支持。

33.java中static变量
	java中 static的int 默认初始值为0；

34.java中Collection的线程安全：
	HashMap和TreeMap都未考虑线程安全。
	HashTable 和 ConcurrentHashMap都是线程安全的，只是加锁的范围不同，HashTable将整个哈希表进行加锁，而ConcurrentHashMap将哈希表分为16桶，每次对需要的桶进行加锁。

35.java中的重载：
	1.在同一个类中。
	2.方法名相同。
	3.方法的形参不同，具体表现为：类型、个数、顺序不同才可以重载。
	4.比较容易忽略的点：与方法的返回类型和访问权限无关。

36.java中的基本类型：
	long a=012；true   因为是基本类型所以编译器会自动进行转型。
	float b=-412； true  同上，      但是float b=-412.2； false  因为java中默认的浮点型为double，所以会报错。

37.java中多线程：
	一定要注意线程调用的是什么方法，如果调用的是start方法则开启一条新线程，但是如果调用的是run方法就只是普通的调用函数，会顺序执行，不会开启新线程。

38.java中的静态方法：
	java的NullPointerException是引用堆内存的对象为空时，才是空指针异常。
	静态方法不依赖对象，所以即使对象为null也可以调用静态方法。   例如： Test t=null；t.hello();  （hello为Test类中公有静态方法）

39.Hibernate优化所鼓励的7大措施：
	1.尽量使用many-to-one，避免使用单项one-to-many
	2.灵活使用单向one-to-many
	3.不用一对一，使用多对一代替一对一
	4.配置对象缓存，不使用集合缓存
	5.一对多使用Bag 多对一使用Set
	6.继承使用显示多态 HQL:from object polymorphism="exlicit" 避免查处所有对象
	7.消除大表，使用二级缓存

40.servlet体系结构，看图。

41.java中抽象类和接口的区别：
	1. 一个子类只能继承一个抽象类,但能实现多个接口
	2. 抽象类可以有构造方法,接口没有构造方法
	3. 抽象类可以有普通成员变量,接口没有普通成员变量
	4. 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)
	5. 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法
	6. 抽象类可以有静态方法,接口不能有静态方法
	7. 抽象类中的方法可以是public、protected;接口方法只有public。

42.javaweb中会话跟踪技术：
	会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。
	HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。
	当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。
	当一个客户在多个页面间切换时，服务器会保存该用户的信息。

	有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。
		1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。
		2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。
		3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP
		    响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个
		    Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至
		    在客户端计算机重启后它仍可以保留其值
		4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话

