1.java中整形默认是int 浮点型默认是double，所以 float f=1.1;  int i=3.0  都是需要强转的。   float正确的定义格式为 float f=0.1f; 要用f来告诉java这个是float类型的小数
2.多线程：java中使用wait必须捕捉异常 而且调用wait或notify方法必须采用当前锁调用,即必须采用synchronized中的对象
3.Java标识符由数字、字母、下划线(_)、美元符号($)或人民币(¥)组成，首位不能是数字。并且Java关键字不能作为标识符。
4.java方法覆盖原则：
	方法的重写（override）两同两小一大原则：
	方法名相同，参数类型相同
	子类返回类型小于等于父类方法返回类型，
	子类抛出异常小于等于父类方法抛出异常，
	子类访问权限大于等于父类方法访问权限。
5.java中abstract：
	含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。
	含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。
	abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。
	如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。
6.java中inteface：
	变量都是 public static final 的，方法都是 public abstract的
	java8之后，interface中可以定义 default 方法和static 方法，static 方法只能通过接口名调用，不能通过实现类名调用。default方法只能通过接口实例调用，并且可以在实现类中覆盖。
		两个接口拥有相同的static方法没关系，可以通过接口类名区分。但是拥有两个相同的default方法就必须在实现类中覆盖这个方法，否则编译器报错。

7.java的异常结构：
				Throwable
				/       \
			    Exception   Error
		    程序可处理异常      (非检查异常）
					程序无法处理的错误
					OutofMemoryError
					stackoverflowError
		    /	       \	
	   非检查异常   	    非运行时异常
	   RuntimeExcepion  	    检查异常
	   NullPointerException     IOException
ArrayIndexOutofBoundsException      EOFEception
ArithmeticException		    FileNotFoundException
NumberFormatException		    SQLExcpetion


8.java线程：
	run是线程执行的方法。
	start是启动线程对象，使之从新建状态转入就绪状态；
	sleep让线程睡眠一段时间，在此期间线程不消耗CPU资源；
	suspend使线程挂起，暂停执行， 如果想恢复线程，必须由其他线程调用 resume方法。
9.java中byte：
	byte b1=1,b2=2,b3;
	b3=(b1+b2)   是错误的，因为在计算时，byte会被转换为int类型进行计算，在计算完应该使用强转  正确格式：b3=(byte)(b1+b2);
	但是当变量是final类型就不会在计算时进行类型转换。
	例如：final byte b4=4,b5=5;  b3=b4+b5;
10.java中线程安全类：简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration

11.java中加载器：
	1）Bootstrap ClassLoader引导类加载器，加载java的核心库，使用原生代码实现的
 
	负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

	2）system class loader 系统类加载器，根据java应用的类路径（classpath）来加载类
 
	2）Extension ClassLoader扩展类加载器，加载java的扩展库
 
	负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
 
	3）App ClassLoader，tomcat为每个APP创建一个loader,里面保存着此webapp的classloader。需加载webapp下的类时，就取出classloader来使用。
 
	负责记载classpath中指定的jar包及目录中class
 
	4）Custom ClassLoader
 
	属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader
 
	加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，
	只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

12.java的参数传递：
	class Value{
		public int i=15;
	}
	public class Test{
		public static void main(String argv[]){
			Test t=new Test( );
			t.first( );
		}
 
		public void first( ){
			int i=5;
			Value v=new Value( );
			v.i=25;
			second(v,i);
			System.out.println(v.i);
		}
 
		public void second(Value v,int i){
			i = 0;
			v.i = 20;
			Value val = new Value( );
			v = val;
			System.out.println(v.i+" "+i);
		}
	}

	输出顺序 15 0 20

13.java中多线程：
	Java中的多线程是一种抢占式的机制，而不是分时机制。抢占式的机制是有多个线程处于可运行状态，但是只有一个线程在运行。 
	共同点 ： 
		1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 
		2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
		如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，
		则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 
		需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，
		如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，
		就会立刻抛出InterruptedException 。 
	不同点 ：  
		1.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 
		sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 
		2.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
		3.sleep，wait,join必须捕获异常，而notify和notifyAll不需要捕获异常 
		4.sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
		5.wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁,只有针对此对象发出notify方法（或notifyAll）后
		本线程才进入对象锁定池准备获得对象锁进入运行状态。

14.java的字符码集：
	java使用的是Unicode字符码，ASCII是国际使用最广泛的字符编码，BCD是一种数字压缩存储编码。Unicode中无论什么字符都是两个字节。

15.java中变量的范围：
	short -2^15  2^15-1
	int   -2^31  2^31-1
	long  -2^63  2^63-1
	float  -2^31  2^31-1
	double -2^63  2^63-1
	boolean 默认false

16.使用泛型取代非泛型的数据类型，程序的运行性能不会更好，因为java在编译阶段，虚拟机就会把泛型擦除，还原成没有泛型的代码，顶多编译时候慢点，运行时没有任何区别。
17.java中spring：
	Spring 框架是一个分层架构！！！由 7 个定义良好的模块组成。
	核心容器，Spring上下文，Spring AOP， Spring DAO， Spring ORM， Spring Web， Spring MVC。这些都是spring包含的框架

17.java的finalize：
	只有当没有引用指向这个对象的时候，垃圾回收器要回收这个对象时，才会调用这个方法。

18.java中的关键字
	1，Java 关键字列表 (依字母排序 共50组)：
		abstract, assert, boolean, break, byte, case, catch, char, class, const（保留关键字）,
		continue, default, do, double, else, enum, extends, final, finally, float, for, goto（保留关键字）, 
		if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, 
		return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
	2，保留字列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：
		byValue, cast, false, future, generic, inner, operator, outer, rest, true, var, goto （保留关键字） , const （保留关键字） , null

	true和false是boolean类型的变量，是编译器赋予特殊含义的，但并不是关键字。

19.截至jdk1.8，java并发框架支持的锁：
	读写锁、自旋锁、乐观锁。

20.java多线程：
	synchronized 关键字 : 用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。
	volatile：用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，
		  因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，
		  因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。
	
21.java中join的作用：
	等待调用join的线程执行完才执行当前线程。

22.java中collection的继承结构：
	看图

23.java中字符串（重点）
	String str1="hello";
	String str2="he"+"llo";
	str1==str2  //true
	因为str1和str2都是常量，当java字符串常量池中存在hello时，str不会再生成一个新的字符串存到常量池，而是直接在常量池取"hello",所以实际上str1和str2指向同一个对象。
	
	String str1="hello";
	String str2="he"+new String("llo");
	str1==str2  //false
	因为str1声明后，java将"hello"存在字符串常量池中，str2在声明时并不知道str2的内容是什么，所以不会放到字符串常量池中，而是放在堆中存储。

24.java国际化：
	实现国际化的常用手段是利用ResourceBundle类

25.面向对象编程语言核心：
	封装、继承、多态
26.java中集合：
	hashMap 允许key和value都可以为null
	hashtable 不允许key和value为null

27.object中含有的默认方法：
	getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(),  wait(), finalize()

28.java中堆的分配：
	-Xmx：最大堆大小
	-Xms：初始堆大小
	-Xmn:年轻代大小
	-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
	年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。
	-Xms初始堆大小即最小内存值为10240m

29.java中的编译问题:
	J2SDK是编程工具，不是API.
	Appletviewer.exe 就是用来解释执行java applet应用程序的,简单理解就是没有main函数的继承applet类的java类。
	能被Appletviewer成功运行的java class文件没有main()方法

30.java中多线程：
	CyclicBarrier和count DownLatch都可以让一组线程等待其他线程。
	Callable 中的call（）方法可以返回值和跑出异常（checkedException）

31.java中的初始化顺序：
	初始化父类中的静态成员和静态代码快，初始化子类中的静态成员和静态代码块。初始化父类中普通成员变量和代码块，再执行父类中的构造方法。初始化子类中的普通成员变量
	和代码块，再执行子类中的构造方法。

32.java中的标准statement
	1.statement是最基本的用法，采用字符串拼接的方法，存在sql注入漏洞。
	2.preparedstatement对statement中的sql语句进行预编译，同时检查合法性，效率高。
	3.CallableStatement接口扩展PreparedStatement，用来调用存储过程，它提供了对输入和输出参数的支持，CallableStatement接口还具有对PreparedStatement接口提供的输入
	  输出的参数支持。

33.java中static变量
	java中 static的int 默认初始值为0；

34.java中Collection的线程安全：
	HashMap和TreeMap都未考虑线程安全。
	HashTable 和 ConcurrentHashMap都是线程安全的，只是加锁的范围不同，HashTable将整个哈希表进行加锁，而ConcurrentHashMap将哈希表分为16桶，每次对需要的桶进行加锁。

35.java中的重载：
	1.在同一个类中。
	2.方法名相同。
	3.方法的形参不同，具体表现为：类型、个数、顺序不同才可以重载。
	4.比较容易忽略的点：与方法的返回类型和访问权限无关。

36.java中的基本类型：
	long a=012；true   因为是基本类型所以编译器会自动进行转型。
	float b=-412； true  同上，      但是float b=-412.2； false  因为java中默认的浮点型为double，所以会报错。

37.java中多线程：
	一定要注意线程调用的是什么方法，如果调用的是start方法则开启一条新线程，但是如果调用的是run方法就只是普通的调用函数，会顺序执行，不会开启新线程。

38.java中的静态方法：
	java的NullPointerException是引用堆内存的对象为空时，才是空指针异常。
	静态方法不依赖对象，所以即使对象为null也可以调用静态方法。   例如： Test t=null；t.hello();  （hello为Test类中公有静态方法）

39.Hibernate优化所鼓励的7大措施：
	1.尽量使用many-to-one，避免使用单项one-to-many
	2.灵活使用单向one-to-many
	3.不用一对一，使用多对一代替一对一
	4.配置对象缓存，不使用集合缓存
	5.一对多使用Bag 多对一使用Set
	6.继承使用显示多态 HQL:from object polymorphism="exlicit" 避免查处所有对象
	7.消除大表，使用二级缓存

40.servlet体系结构，看图。

41.java中抽象类和接口的区别：
	1. 一个子类只能继承一个抽象类,但能实现多个接口
	2. 抽象类可以有构造方法,接口没有构造方法
	3. 抽象类可以有普通成员变量,接口没有普通成员变量
	4. 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)
	5. 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法
	6. 抽象类可以有静态方法,接口不能有静态方法
	7. 抽象类中的方法可以是public、protected;接口方法只有public。
	8. 抽象类中方法默认的访问权限是default，接口是public。

42.javaweb中会话跟踪技术：
	会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。
	HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。
	当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。
	当一个客户在多个页面间切换时，服务器会保存该用户的信息。

	有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。
		1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。
		2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。
		3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP
		    响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个
		    Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至
		    在客户端计算机重启后它仍可以保留其值
		4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话

43.servlet是不是线程安全的？
	servlet在多线程下其本身并不是线程安全的。
	如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。
	最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。
	由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。

44.java中的堆栈分别储存什么：
	栈：线程私有的，存放局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，
	    非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
	堆：用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配
	方法区：方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，
		当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，
		当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。
	常量池：存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。
	http://www.cnblogs.com/liulipeng/archive/2013/09/13/3319675.html

45.java中finally的执行时间：
	不管try中有没有catch到异常，finally都会执行
	当try中有return时，跳转到finally中执行全部代码后结束。
	当catch中有return时，同上。
	当try或catch中有System.exit(0)直接结束程序

45.java中局部变量一定要初始化，否则编译出错。

46.java中 int 和Integer 的比较问题：
	两个int只是常量的普通比较，比较两个int的值。
	int a=0;Integer b=new Integer(0);  a==b  //true  因为常量池中有0了，所以Integer b直接从常量池中取值，并没有新建对象，所以是true。
	但是非常重要的一点：两个Integer比较：  
		Integer a=new Integer(1); Integer b=new Integer(1);  a==b  //true  因为在范围 -128到127内，常量池有值，从常量池中取。内存地址相同。
		Integer a=new Integer(300);Integer b=new Integer(300); a==b  //false  因为范围超出 -128到127 ，所以新建对象。内存地址不同。
	
47.java中多线程：
	CopyOnWriteArrayList适用于写少读多的并发场景
	ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率
	ConcurrentHashMap是同步的HashMap，读写都加锁
	volatile只保证多线程操作的可见性，不保证原子性

48.getClass().getName()方法
	如果没有重写Object的getClass()方法，就会返回当前类的类名。（getName返回 包名.类名的格式）

49.java中管道(Pipe)：
	管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，
	并且只存在于内存中。它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向 的数据传输，
	而同一个时刻只能最多有一个方向的传输，不能两个方向同时进行。管道的容 量大小通常为内存上的一页，它的大小并不是受磁盘容量大小的限制。
	当管道满时，进程在 写管道会被阻塞，而当管道空时，进程读管道会被阻塞,
	可以有多个线程操作管道，但不能同时进行读写操作。

50.java中的构造函数：
	类中普通方法可以和类名相同，和构造函数的区别就是有返回值。

51.java中的ceil和floor
	ceil：大于等于 x，并且与它最接近的整数。当  x>-1 and x<0  Math.ceil(x)=-0.0;
	floor：小于等于 x，且与 x 最接近的整数。
52.java的volatile：
	所谓 volatile的措施，就是
	1. 每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile修饰的共享变量，每次的更新对于其他线程都是可见的。
	2. volatile保证了其他线程的立即可见性，就没有保证原子性。
	3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。

53.java虚拟机的详细：
	https://www.nowcoder.com/test/question/done?tid=12727582&qid=14817#summary
	链接：https://www.nowcoder.com/questionTerminal/2a1cdf3e61d14947bf00dfe10e25a2c0
	来源：牛客网

	http://www.cnblogs.com/sunada2005/p/3577799.html java虚拟机详解。

	大多数 JVM 将内存区域划分为 Method Area（Non-Heap）（方法区） ,Heap（堆） , Program Counter Register（程序计数器） ,   VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,
	Native Method Stack  （ 本地方法栈 ），其中Method Area 和  Heap 是线程共享的  ，VM Stack，Native Method Stack  和Program Counter Register  是非线程共享的。
	
	为什么分为 线程共享和非线程共享的呢?请继续往下看。
	首先我们熟悉一下一个一般性的 Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上
	，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？

	概括地说来，JVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , 
	  VM Stack（虚拟机栈）和Native Method Stack  （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。
	这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，
	所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。


54.java中的多态
package Wangyi;
class Base
{
    public void method()
    {
        System.out.println("Base");
    } 
}
class Son extends Base
{
    public void method()
    {
        System.out.println("Son");
    }
     
    public void methodB()
    {
        System.out.println("SonB");
    }
}
public class Test01
{
    public static void main(String[] args)
    {
        Base base = new Son();
        base.method();
        base.methodB();
    }
}

编译出错，  原因：
	多态：父类型的引用可以指向子类型的对象。
	与函数重载不同
	在方法调用的时候发现，父类里没有的函数，在多态实现的时候不能出现。
	父类里如果有调用的是子类的同名方法。

55.java中多线程：
ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全。将哈希表分16桶，对需要的桶进行加锁。


56.JDK1.7以后
	Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 
	这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类（java.util.Arrays.ArrayList）！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。

57.java中的继承：
	java中的子类可以继承父类的所有数据域和方法，但是父类中私有的变量和方法子类无法访问。
58.java的序列化（serializable）：
	transient关键字修饰的变量不会在序列化时进行序列化。

59.webservice：
	Webservice是跨平台，跨语言的远程调用技术;
	它的通信机制实质就是xml数据交换;
	它采用了soap协议（简单对象协议）进行通信；

60.javaweb：
	getParameter()是获取POST/GET传递的参数值；
	getInitParameter获取Tomcat的server.xml中设置Context的初始化参数
	getAttribute()是获取对象容器中的数据值；
	getRequestDispatcher是请求转发。

61.servlet生命周期：
	Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。
	(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet
	(2)创建：通过调用servlet构造函数创建一个servlet对象
	(3)初始化：调用init方法初始化
	(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求
	(5)卸载：调用destroy方法让servlet自己释放其占用的资源

62.java正则表达式
	"com.jd.".replaceAll(".","/")+"myclass.class";
	结果为："///////myclass.class"  因为在正则中.代表任何字符,只替换.应该写成    replaceAll("\\.","/")

63.SpringMVC的原理：
	SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,
	前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，
	前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，
	前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。
	DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。
	实现业务操作时在service层.

64.java的命令行工具
	javac.exe是编译.java文件
	java.exe是执行编译好的.class文件
	javadoc.exe是生成Java说明文档
	jdb.exe是Java调试器
	javaprof.exe是剖析工具

65.Spring中的事务：
	事务属性的种类：   传播行为、隔离级别、只读和事务超时
  
	a)    传播行为定义了被调用方法的事务边界。
 
	传播行为
	意义
	PROPERGATION_MANDATORY
	表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常
	PROPAGATION_NESTED
	表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED 看起来没什么俩样
	PROPAGATION_NEVER
	表示方法不能运行在一个事务中，否则抛出异常
	PROPAGATION_NOT_SUPPORTED
	表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起
	PROPAGATION_REQUIRED
	表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务
	PROPAGATION_REQUIRES_NEW
	表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起
	PROPAGATION_SUPPORTS
	表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中
		 
 
	b)    隔离级别
	在操作数据时可能带来 3 个副作用，分别是脏读、不可重复读、幻读。为了避免这 3 中副作用的发生，在标准的 SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，如下：
	隔离级别
	意义
	ISOLATION_DEFAULT
	使用后端数据库默认的隔离级别
	ISOLATION_READ_UNCOMMITTED
	允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读
	ISOLATION_READ_COMMITTED
	允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读
	ISOLATION_REPEATABLE_READ
	一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读
	ISOLATION_SERIALIZABLE
	这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。
 
 
	c)    只读
	如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。
	因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。
	如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。
	d)   事务超时
	如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设
	置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。


66.java中的枚举（底层实现）
	枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：
	private AccountType(){ System.out.println(“It is a account type”); }
	会变成：
	private AccountType(String s, int i){
	   super(s,i); System.out.println(“It is a account type”); }
	而在这个类中，会添加若干字段来代表具体的枚举类型：
	public static final AccountType SAVING;
	public static final AccountType FIXED;
	public static final AccountType CURRENT;

	而且还会添加一段static代码段：
	static{
	SAVING = new AccountType("SAVING", 0);
	 ...  CURRENT = new AccountType("CURRENT", 0);
	$VALUES = new AccountType[]{
		 SAVING, FIXED, CURRENT
	    } }
	以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）
	在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。











	