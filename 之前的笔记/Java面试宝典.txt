------------------------------------------------------------------多态实现的机制是什么？
	Base b;    Sub extends Base;
当  Base b = new Sub();时。当b调用方法时候，Sub中有同名函数，就会覆盖Base中的函数，这叫运行时多态，具体看实例的类型来调用方法。，即new Sub（）
但是，成员变量无法实现多态，Base中的i为1，Sub中的i为2。当Base b=new Sub（）时，输出i，这时i为1。因为这取决于引用变量的类型，即Base b，是在编译期间确定的。
具体分为：编译时多态（通过方法的重载实现）和运行时多态（通过方法的覆盖实现）


------------------------------------------------------------------重载和覆盖的区别。

1重载：
	重载要通过不同的参数类型、参数方法来进行重载。
	不能通过权限访问修饰符、抛出的异常、返回值类型来进行重载。
	如果访问权限为private ，就不能重载，只是定义了一个新的方法而已。

2.继承：
	继承要有相同的参数和函数名。
	返回值相同
	抛出的异常一样。
	被覆盖的方法不能是private

覆盖和继承是垂直关系，而重载是方法和方法之间的关系，是水平关系。
覆盖只能由一个方法或者一对方法产生关系，重载是多个方法之间的关系。
覆盖要求参数完全相同，而重载要求不同。
覆盖根据对象的类型调用方法，而重载是根据实参形参表来调用。

------------------------------------------------------------------接口和抽象类有什么异同

接口中的变量都是 static final 的  方法都是public adstract的。

相同点：
	都不能被实例化。
	接口的实现类和抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。

不同点：
	接口只有定义，不能有具体实现的方法。而抽象类中可以有部分方法体。
	接口需要实现，而抽象类只能被继承。一个类可以实现多个接口。
	接口强调“has a”的关系，而抽象类强调所属关系，即“is a”。
	抽象类中的方法不能被private static synchronized、native等访问修饰符修饰。
	接口用于实现较为常用的功能，而抽象类更多的充当公共类的角色。

此外，接口可以继承接口，抽象类可以实现接口，抽象类也可以继承具体类，抽象类也可以有静态的main方法。



------------------------------------------------------------------各种内部类

静态内部类：
	不依赖外部类实例而实例化。
	只能访问外部类的静态成员和静态方法。

成员内部类：
	可以自由引用外部类的属性和方法。
	不可以定义静态属性和方法。
	只有外部类实例化，它才会实例化。
	非静态内部类中不能有静态成员。

局部内部类：
	不能被权限修饰符修饰和static修饰
	只能访问方法中被定义为final的变量

匿名内部类：
	不能使用关键字class、extends。implements
	必须继承其他类或实现其他接口。
	不能有构造函数、不能定义静态成员方法和类、不能使public private protected、static
	只能创建匿名内部类的一个实例。
	一个匿名内部类一定是跟在new的后面，这个匿名内部类必须继承一个父类或实现一个接口。


----------------------------------------------------------------
不能在成员函数内部定义static变量。

---------------------------------------------------------------基本数据类型--------------------------------------------------------------------
Java中的八种基本数据类型：int long short float double byte char boolean ,  对应的封装类型：Integer Long Short Float Double Byte Character Boolean 。
还有一种基本类型void，对应封装类java.long.void
原始数据类型在传递参数时都是按值传递，而封装类型都是按引用传递的。

小数默认是double类型的，在赋给float时注意强制类型转换。   
byte的范围是【-128，127】

byte<short<char<int<long<float<double   在进行计算时，可以自动从低等转到高等。

------------------------------------------------------------------String-------------------------------------------------------------------
String类型是不可变的，所以要是 String s="hello";  s+="world";会耗时间。
StringBuffer是可变的，同时也是线程安全的。如果经常改变的话，会比用String好很多。
StringBuilder也是可变的，但是相比于StringBuffer来看，StringBuilder是线程不安全的，所以在单线程中，使用StringBuilder好一些，效率比StringBuffer高

Stringtokenizer是用来分割字符的。



---------------------------------------------------------------异常处理----------------------------------------------------------------------
如果在try中有return的话，就会先跳到finally中执行finally中的代码，如果finally中有return的话，就会执行finally中的return，覆盖try中的return。

finally中对基本类型的变量进行修改不会影响return的结果。如果是对引用类型的变量，就会影响return的结果。

finally语句块是不是一定会执行？    答案是不一定会被执行。（1）如果在进入try语句块之前就产生异常，就不会进入finally语句块中。（2）try中有System.exit（0）；

采用装饰者设计模式


---------------------------------------------------------------javaNIO（noblocking IO）-------------------------------------------------------

采用反应者设计模式
通过Selection、Channel和Buffer来实现。




------------------------------------------------------------------序列化Serializable----------------------------------------------------------
static 和 transient 标记的属性或方法不会进行序列化。

-------------------------------------------------------------Java基本原理+--------------------------------------------------------------------
Java是一个纯软件的平台，可以运行在一些基于硬件的平台。主要包含两个模块：JVM和JavaAPI。
JVM是虚构出来的计算机，用来把Java编译生成的中间代码转换成机器可以识别的编码并运行。当一个Java程序运行时，都会有一个对应的JVM实例。

------------------------JVM加载class文件的原理机制是什么？

Java是一种具有动态性的语言，class只有被加载到了JVM中后才能运行。
类的加载分为隐式和显式：
	隐式指 通过 new 等方式创建对象时，隐式的调用类加载器把对应的类加载到JVM中去。
	显式指 通过Class.forName的方式来把需要的类加载到JVM中去。

类的加载是动态的，不会一次性把所有类都加载了，而是先加载基础类，当有需要时再去加载所需要的类。

类加载主要分成三步：
	（1）装载
	（2）链接：
		1)检查：检查待加载的class文件的正确性。
		2)准备：给类中的静态变量分配存储空间。
		3)解析：将符号引用转换成直接引用。
	（3）初始化


-------------------------------------------------------------------Java垃圾回收----------------------------------------------------------------
垃圾回收器的三项任务：分配内存、确保被引用对象的内存不被错误地回收、回收不再被引用的对象的内存空间。

对于垃圾回收器，它使用有向图来记录和管理堆内存中的所有对象。

-----------------几种垃圾回收算法：
（1）引用计数法：记下对象有几个引用，没有引用时回收。
（2）追踪回收法：遍历引用图，当有引用就标记，结束遍历后回收没有标记的对象，
（3）压缩回收法：把堆中活动的对象转移到一侧。大大简化回收碎片的工作，但每次处理会带来性能的损失。
（4）复制回收法：把堆分成两个大小相等的区域，只有其中一个区域是被使用的，耗完后，将活动的对象复制到另一个空的区域内。
（5）按代回收算法：把堆分成几个区域，活跃的放到一个堆，不活跃的放到一个堆。活跃的堆不会每次都扫描。

一旦一个对象成为了垃圾，不会立刻被回收，而是等到下一次回收器运行时再回收。
finalize方法是在对象被回收之前调用。

--------------------------------------------------------------内存泄漏-------------------------------------------------------------------------
------------------几种情况
（1）静态集合类：static的生命周期和程序一样
（2）各种连接：例如数据库连接等。
（3）监听器：如果监听对象释放后，没有释放监听器就会造成内存泄漏
（4）变量的不合理作用域：明明只在函数内部有作用的变量，定义成为了成员变量。
（5）单例模式可能会造成内存泄漏：当单例模式的实例拥有一个成员变量时，这个单例总是持有这个成员变量无法释放。


--------------------------------------------------------------堆和栈+--------------------------------------------------------------------------
栈是用来存放基本类型数据和引用变量（注意是引用变量而不是实例变量）的
堆是用来存放运行时建立的对象（比如通过new来创建的）。

从功能和作用来比较，堆是用来存放对象的，栈是用来执行程序的。而且栈的存取速度更快。

------------------------------------------------------------Collection-------------------------------------------------------------------------

----------------------Set
Set中的元素不能重复
TreeSet是有序的。

----------------------Map
Map中的值可以重复但是Key不可以重复。
HashMap是基于散列表实现的，采用对象的HashCode来进行快速查询。
LinkedHashMap是基于列表实现的。
TreeMap是基于红黑树来实现的，内部是按需排序的。


Vector是线程安全的，而ArrayList不是。



HashMap查找过程，
先通过HashCode找到一部分Key，再通过equals方法来比较key，如果相等，取出value


-------------------------------------------------------------多线程----------------------------------------------------------------------------

线程一共有四种状态
	运行、就绪、挂起、结束。

各个线程之间共享程序的内存空间（代码段、数据段、堆空间）


多线程带来的便利：
	1.使用多线程可以减少程序的响应时间
	2.与进程相比，线程的创建开销更小，
	3.多CPU或多核计算机本身就具备执行多线程的能力，不用就浪费了。
	4.多线程能简化程序结构，便于维护和理解。


一个类是否可以既继承Thread又实现Runnable？
	可以，Thread中的run方法会看作是对Runnable中run方法的实现。

run（） 和start（）有什么区别
	直接调用run只会被认作是一个普通方法，必须调用start方法，才能异步地调用run方法。




-----------------------------------实现多线程的方法有哪些
1.synchronized关键字。
（1）可以修饰方法和synchronized块。
（2）wait 和 notify方法
	wait释放对象锁，进入等待状态，并且可以调用notify或notifyAll方法通知其他等待的线程获得锁
	notify 唤醒等待中的线程，让他们可以获得锁（notifyAll让所有对象可以去竞争锁）
（3）lock
	1）lock 阻塞式，一直等待，直到获得锁。
	2）tryLock 非阻式获得锁，获得锁立刻返回true ，否则立刻false；
	3）tryLock（long timeout，TimeUnit unit） 如果获得了锁，立刻返回true，否则会等待参数给定的时间单元。、
	4）lockInterruptibly（） 获得锁返回，没获得休眠。直到获得缩。


----------------------------------sleep和wait方法的区别

（1）原理不同：sleep是Thread类的静态方法，是线程用来控制自身流程的，会使线程暂停执行一段时间。
（2）对锁的处理机制不同：sleep方法不会释放锁，wait方法会释放掉它占用的锁。
（3）使用区域不同：wait方法必须放到同步控制方法或同步代码块中，但是sleep可以在任何地方使用。
		   sleep必须捕获异常，而wait notify  notifyAll不用捕捉异常。


----------------------------------终止线程的方法有哪些？
现在不推荐使用stop和suspend方法了，应为容易造成死锁。

都是用一个boolean类型的一个变量作为标记，来控制run方法中while循环的结束。但是，如果while其中有被阻塞了，就停止不了了，所以还要用interrupt方法来打破阻塞。这时候会抛出异常，然后捕捉异常来达到安全退出线程的目的。




-----------------------------------synchronized和Lock有什么异同，

Lock可以使用Condition来达到synchronized的所有功能。


区别：
（1）用法不一样，synchronized是加在方法上或者在特定代码块中，括号表示需要锁的对象。
（2）性能不一样，在资源竞争不激烈的情况下，synchronized的性能比较好，但是资源竞争激烈，ReetrantLock的性能比较好。
（3）锁机制不一样，Lock需要手动解锁，并且必须在finally中释放，否则会引起死锁的问题。




-----------------------------------什么是守护线程？

守护线程一直存在，当所有非守护线程都结束了，JVM会自动退出，这时候守护线程自动关闭。
可以通过setDaemon（boolean ）的方法来设置一个线程为守护线程。


-----------------------------------join方法的作用是什么？

在B中调用A的join方法会将A的run执行完毕后继续执行B。
可以join（timeout）来设置等待时间。




