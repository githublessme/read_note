
									第一章 Mysql架构和历史
mysql服务器逻辑架构
	第一层：连接/线程处理（这是大多数基于网络的客服端/服务器的工具或服务都有的类似的架构）
	第二层：查询缓存-解析器
			   |
			优化器
		这是mysql的核心功能，包括查询、分析、优化、缓存以及所有的内置函数,所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图
	第三层：包括存储引擎。负责mysql中数据的存储和提取,服务器通过API和存储引擎进行通信，不同的存储引擎不会进行通信

mysql查询的步骤：
	0.先查询缓存，如果有相同的查询，则直接从缓存中取数据，否则从步骤1开始执行（仅限select操作）
	1.mysql解析查询
	2.创建内部数据结构（解析树）
	3.对其进行优化（优化器）
	4.执行查询
	(优化器并不关心表使用的是什么引擎,(透明))

并发控制：服务器层和存储引擎层
	两种锁机制：读锁和写锁（共享锁和排他锁）

锁粒度：
	尽量只锁定需要修改的部分，而不是所有资源，这样可以达到最良好的并发性。
	一般都是在表上施加行级锁

	表锁：mysql最基本的锁策略，锁资源的开销最少。  写锁比读锁具有更高的优先级。写锁可以在队列中插入到读锁前面。
	行级锁：最大程度支持并发，！！！！行级锁只在存储引擎层实现。服务器完全不了解存储引擎中的锁实现。
	
事务：ACID （A：原子性，C:一致性 I:隔离性 D:持久性）

隔离级别：
	READ UNCOMMIT 读未提交：可以读取其他事务中未提交的数据，可以引发脏读的发生。
	READ COMMIT   读已提交：大多数数据库系统默认的是这个级别的隔离，只能看到其他事务提交的修改。一个事务从开始到提交所做的事情对其他的事务是不可见的。这也叫不可重复读。
	REPEATABLE READ 可重复读：在事务进行时，向范围内插入了一条新数据，这个事务再读取这个范围的数据时就会出现幻行，也叫幻行。幻读
	SERIALIZABLE	串行化 ：在读取的每一行数据上加锁。这样锁开销太大，而且并发性不好，一般情况下不会用这种隔离级别。


死锁：
	事务1：
		请求Id为1的数据行
		请求Id为2的数据行
	事务2：
		请求Id为2的数据行
		请求Id为1的数据行
	当下面这两个事务同时开始，给第一行的数据加锁，然后执行第一步的操作，之后去请求第二步操作时，两个事务的第二步操作都被对方的事务加了锁，谁也不会请求到资源，所以产生了死锁。
	
	解决方案：InnoDB：将持有最少行级排他锁的事务进行回滚。
	锁的行为和顺序是存储引擎相关的。


事务日志：存储引擎在修改表的时候，只需要修改内存拷贝，再将修改行为写到事务日志中，而不用每次都将修改持久化到磁盘中。然后事务日志采用追加的方式，将修改持久化到磁盘中，
	  然后内存中被修改的数据再慢慢的刷到磁盘中去。


mysql中的事务：
	mysql的两种支持事务的存储引擎：InnoDB和NDB Cluster。
	自动提交：mysql默认 autocommit。
	在事务中混合使用存储引擎：
		这样在不出问题的时候没什么区别，但是如果出现问题需要回滚的时候，事务型的表将数据回滚，而非事务型的表无法将数据回滚，会造成数据不一致的情况。

多版本并发控制：
	大多数事务型的存储引擎不光是实现了行级锁，还实现了MVCC（多版本并发控制）
	InnoDB的MVCC：
		通过在每行记录后面添加两个隐藏的列来实现：行创建的时间，和过期时间。（都是存的版本号，而不是时间）
		select会根据以下两个条件检查每行记录：
			a.之查找版本号早于当前事务版本的数据行
			b.行的过期时间未定义或大于当前版本的（大于当前版本号，说明已经在当前事务进行过程中已经完成事务的数据行）
		insert
			为新插入的每一行保存当前系统版本号作为行创建时间
		delete
			为删除的行保存当前系统版本号作为过期时间。
		update
			InnoDB为插入一行新纪录，保存当前版本号作为行的创建时间，同时保存当前版本号作为原来的行的过期时间


mysql的存储引擎：
	不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在mysql服务层统一处理的。
	

	InnoDB：
		是mysql的默认事务型引擎，也是最重要，应用最广泛的存储引擎。   性能好，自动崩溃恢复特性。
		采用MVCC来支持高并发，其默认的隔离级别是REPEATABLE READ（可重复读）,用间隙锁来防止幻读的发生。
		基于聚簇索引建立的。
	MYISAM：
		不支持事务和行级锁。崩溃后无法安全恢复。
		不支持行级锁，对整张表加锁。
		支持空间索引，可以用作存储地理信息。能够从任意维度进行索引查询。
		MYISAM压缩表：
			表在导入数据后，不会再进行修改操作，可以采用MYISAM压缩表。减少磁盘占用，提升查询性能。支持索引，但是只读。
	Archive：
		只支持insert和select操作，缓存所有写操作，并通过zlib对插入的行进行压缩，比MYISAM I/O更少，但是select会查询全表。
		支持行级锁，在一个查询开始到返回所有存在的数据，其他的select会被阻塞。保证一致性的读。

	CSV：
		不支持索引，可以和excel数据相互转换，可以作为一种数据交换的机制。
	Federated：
		是访问其他mysql服务器的一个代理，会创建一个远程的链接，并将查询传输到远程的服务器上执行。然后提取或发送需要的数据。
	Memory：
		数据保存在内存中，不进行持久化操作，重启数据会丢失。但是要比MYISAM快一个数量级
		应用场景：
			用于查找或映射表，例如将邮编和州名映射的表
			用于缓存周期性聚合数据的结果。
			用于保存数据分析产生的中间数据。
		Memory支持hash索引，查找非常快。
		表级锁，并发写入性能较低。不支持BLOB和TEXT
		

选择存储引擎需要考虑的因素：
	1.事务：如果需要事务，则应该使用事务型存储引擎，如：InnoDB。如果不需要事务，只要是进行select insert 操作，MyISAM是不错的选择。
	2.备份：如果可以定期关闭服务器执行备份，则不需要考虑。如果需要在线热备份就应该选择InnoDB。
	3.崩溃恢复：如果需要良好的崩溃恢复功能，则选择InnoDB比较好。
	4.特有的特性：

	
	日志型应用：这种应用对插入速度有很高的要求，数据库不能成为瓶颈，这时候可以使用MYISAM或者Archive存储。
			但是如果需要对日志做分析，就会非常慢。这时候可以使用mysql内置的复制方案复制一份，然后在这个复制的表进行耗时比较高的查询操作。
	
	只读或者大部分情况下只读的表：
			读多写少的业务，不介意崩溃恢复的问题，可以选用MyISAM。但是不要小看崩溃恢复问题，最好选用InnoDB
	
	订单处理：肯定支持事务，选用InnoDB等事务型存储引擎。
	

转换表的存储引擎（三种方法）:
	alter table ： alter table mytable engine = InnoDB；
	导入与导出：先导出修改存储引擎后导入回去，导入前记得删掉旧表
	创建与查询：create table new_table like old_table；
		    alter table new_table engine = InnoDB；
		    insert into new_table select * from old_table;


										第四章Schema与数据类型优化
4.1选择优化的数据类型
	更小的通常更好：更小的通常更快
	简单就好：简单数据类型的操作通常需要更少的CPU周期
	尽量避免null，但是当后台处理非null数据吃力时，也没有必要非要避免null，要根据实际情况选择。
	

4.1.1整数类型
	UNSIGNED属性，表示不允许负值，可以使正数的上限提高一倍。

4.1.2实数类型
	实数是带小数的部分的数字，但是也可以使用DECIMAL存储比BIGINT还大的整数。
	
4.1.3字符串类型
	varchar用于存储可变长字符串，比定长更节省空间。varchar需要1到两个字节存储字符串长度。varchar节省了存储空间，所以对性能有帮助，但是行是变长的，在update时可能使行变得
	更长，这有可能需要额外的工作。
	
	varchar的适用情况：
		字符串列的最大长度比平均长度大得多。列的更新很少，所以碎片不是问题。使用了像UTF-8这样复杂的字符集，每个字符都适用不同的字节数进行存储。
	InnoDB把过长的varchar存储为BLOB
	
	char是固定长度的，总是为字符串分配足够的空间。会自动截断末尾的空格
	char的适用情况：
		存储很短的字符串。所有值都接近同一个长度。像是存储密码的MD5值，因为这是一个定长的值。对于非常短的列，用char更有优势，因为不用像varchar那样在末尾存储字符串长度。
	
	Memory只支持定长的行，即使有变长的字段，也会根据最大长度分配空间。

	最好只分配真正需要的空间，如果能用varchar（5）就不要用varchar（20）
	
	BLOB和TEXT类型：
		都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

		进行排序的方式跟其他字符串类型不同，是根据每列最前max_sort_length字节而不是整个字符串做排序。
		
		Memory引擎不支持BLOB和TEXT。

	使用枚举（ENUM）代替字符串类型
		create table enum_text(
			e enum('fish','dog','apple') NOT NULL
		);
		insert into enum_test(e) values ('fish'),('dog'),('apple');
	因为mysql在存储枚举类型的时候，会将数据压缩成一到两个字节。实际存储的是数字。排序方式是按照内部数字排序而不是字符串。
	枚举最不好的地方就是，字符串列表是固定的，添加和删除字符串必须使用alter table
	

4.1.4时间类型
	DATETIME和TIMESTAMP
	一般情况应该选择TIMESTAMP，因为它比DATETIME空间效率更高。

4.1.6选择标识符
	在存储标识符的时候（我理解为主键），不应该选择使用字符串类型，因为比较起来复杂，效率低。

	一些技巧：
		整数类型通常是最好的选择，他们很快并且可以使用AUTO_INCREMENT
		ENUM和SET通常是糟糕的选择，
		字符串类型，如果有可能，尽量避免使用字符串类型作为标识列，因为它们很耗空间，而且比数字类型慢。尤其是MyISAM存储引擎，默认对字符串进行压缩索引，导致查询很慢。
		对于完全随机的字符串，如md5，uuid等，新值会任意分布在很大的空间内。导致insert和select语句变得很慢。p126 等学差不多了回过来再看。尽量避免随机IO
4.1.7特殊类型数据
	如IPv4的IP地址，并不是字符串而是无符号整数，应该通过INET_ATON()和INET_NTOA()这两个函数来相互转换。


4.2mysql中schema 设计缺陷
	1.太多的列，如果一个表中拥有太多的列，恰好这个表中又有很多变长的数据，例如varchar，如果只有一小部分数据是我们需要的话，存储引擎和服务层之间的数据交换就要转换这些数据，
	  代价会非常高。
	2.太多的关联：单个查询最好在12个表内做关联。
	3.全能的枚举：注意防止过度使用枚举，枚举值过多时影响查询效率，而且在修改枚举值时要通过alter table操作，在末尾增加值。
	4.变相的枚举：在一个set中有 yes和no，yes和no并不会同时出现，所以应该使用枚举类型。
	5.非此发明的null：尽量避免null，但是不要害怕使用null。如果判断null的时候操作太过繁琐，也可以使用null

4.3范式和反范式：
	在范式化的数据库中，一个事实数据只会出现一次，而在反范式化的数据库中数据时冗余的。

4.3.1范式化的好处：
	1.范式化的更新操作更快
	2.数据较好的范式化时，没有重复数据，所以只需要修改很少的数据。
	3.范式化的表通常更小，可以很好的放在内存中，执行操作会更快。
	4.有很少的数据意味着很少使用distinct或者groupby

范式化的缺点：
	通常需要关联。这种代价通常很高昂，也可能使一些索引无效。例如，范式化的可能将列存储在不同的表中，而这些列如果在一个表中本可以属于同一个索引。

4.3.2反范式化的好处：
	1.避免关联，当数据比内存大的时候查询很快，避免了随机IO
	2.将两张表的数据进行合并有的查询不需要关联，而且可以使用索引。（orderby 和groupby会很快）
		
4.3.3混用范式化和反范式化：
	例如：可以在user表中和message表中都存储account_type列，避免了完全反范式化的插入和删除问题，即使没有消息也不会丢失用户信息，可以高效的利用数据。但是现在更新的代价就高了
	      需要同时更新两张表，这种代价需要我们自己衡量。
	例如：像是论坛这类网站，统计用户发信息次数，不需要使用count来计算，可以在user表中缓存num_message字段，每当用户发消息时更新这个字段。

4.4缓存表和汇总表
	等学差不多了回来看
	影子表：很关键的一个东西
		drop table if exists table_new ,table_old;
		create table table_new like table;
		复制数据
		rename table to table_old.table_new to table;  
		这样直到下一次复制表之前，旧表一直存在。

4.4.1物化视图
	等回来学差不多了回来再看

4.4.2计数器表
	创建一张独立的表来存储计数器通常是一个好主意，这样可以使计数器小且快。
	但是一张表只有一行点击次数的话并发性并不好，所以可以存储几个点击的行来进行并发的存储，需要计算点击次数时，再把他们相加。
	create table hit_counter(
		slot tinyint unsigned not null primary key,
		cnt int unsigned not null
	)engine=InnoDB;
	update hit_counter set cnt=cnt+1 where slot = rand()*100;  从1到100id的计数器随机进行更新，最后相加计算点击次数。

	insert into hit_counter （slot，cnt）values（rand（）*100，1）on duplicate key update cnt=cnt+1； 这样可以不用预先生成100行计数器。有unique或者主键时，重复的话就会更新	而不是进行插入操作。


为了提高读的速度，有时会建立一些额外索引，增加冗余列，甚至创建缓存表和汇总表。虽然写操作变慢了，但是读操作更快了，写操作变慢并不是读操作变快的唯一代价，还增加了写操作和读操作的开发难度。



4.5加快alter table操作的速度
	一种操作是在一台不提供服务的主机上执行alter table 操作，然后跟提供服务的主机进行交换。
	另一种操作时“影子拷贝”通过重命名和删除表的方式交换两张表。
	
	modify colum操作和alter column 还有change column的区别：
	ALTER COLUMN：设置或删除列的默认值（操作速度非常快）
	CHANGE COLUMN：列的重命名、列类型的变更以及列位置的移动
	MODIFY COLUMN：除了不能给列重命名之外，他干的活和CHANGE COLUMN是一样的
	modify操作会重新创建表并进行数据拷贝，所以很慢。而alter column操作则直接修改.frm文件。    frm文件是mysql存储列默认值的表，所以不用重建表。如果需要更改数据类型就不行了
	

	有可能不需要重建表的操作：
	1.移除（不是增加）一个列的auto_increment属性。
	2.增加、移除或更改enum和set常量
		（1）创建一张结构相同的空表，并进行所需要的修改
		（2）执行flush tables with read lock 将会关闭所有正在使用的表
		（3）交换.frm文件（需要用到系统的命令）
		（4）执行unlock tables 来释放锁

4.5.2快速创建MyISAM索引
	先禁用索引、载入数据，然后重新启用索引
		alter table test.load_data disable keys;
		--load the data
		alter table test.load_data enable keys;
	因为构建索引的工作被延迟到数据完全载入以后，这个时候已经可以通过排序来构建索引了。这样会快很多，并且使得索引树的碎片更少，更紧凑。
	这个方法对唯一索引没用，因为disable keys只对非唯一索引有效，MyISAM会在内存中构造唯一索引。

4.6总结
	尽可能保持任何东西都是小而简单的总是好的。
	1.避免过度设计，会导致极其复杂的查询
	2.使用小而简单又合适的数据类型，尽可能的避免null值
	3.尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列。
	4.注意可变长字符串，在临时表和排序时可能导致悲观的按最大长度分配内存。
	5.尽量使用整型定义标识列
	6.避免使用mysql已经遗弃的特性
	7.小心使用enum和set，不要滥用。

			
			
										第五章 创建高性能的索引
5.1索引基础
	在查找时可以在索引上按值比较，找到对应的索引了，再通过索引找到对应的数据行，来返回数据（InnoDB是基于聚簇索引，存行的所有数据。其他的存行指针（行号））

5.1.1索引的类型
	在mysql中索引是在存储引擎层实现的（行锁是在存储引擎层实现的，表锁是在服务层实现的），所以没有统一的索引标准。（相同的特性都是在服务层实现的）
	
	B-Tree索引：mysql使用的是B+Tree（存储引擎用不同的方式实现B-Tree）。B-Tree能够加快访问数据的速度，因为存储引擎不再需要全表扫描获取需要的数据，取而代之的是从索引的根节点
		    开始进行搜索。
	
	可以使用B-Tree索引的查询类型:
		全值匹配：所有列都在索引里
		匹配最左前缀：只是用索引列的前几列（必须从最左边开始，中间不能断开）
		匹配列前缀：也可以只匹配某一列的开头部分。
		匹配范围值：匹配范围值，规则和最左前缀一样，只能使用从最左边开始的列，中间不能断开，并且范围必须是闭合的，例如：a>5（不行）  a>5 and a<10（可以）
		精确匹配某一列并范围匹配另一列：规则如最左前缀类型，前面的列精确，后面的列可以使范围值
		只访问索引的查询：覆盖索引
	
	不能使用B-Tree索引的查询类型：
		如果某个列带有范围查询，则这个列后面的列都没法用索引优化。
		
	
	哈希索引：
		基于哈希表实现，只有精确匹配索引的所有列的查询才能生效，（不同于B-Tree索引，B-tree索引不要求查询包含所有列）
		在mysql中只有memory支持哈希索引。
		计算每个行的哈希值并且存储该数据行的指针，如果哈希值相同，用链表的形式将这些索引连接起来。
		

		步骤：select lname from testhash where fname='peter',对于该查询，先计算peter对应的哈希值为8784，然后根据8784从哈希表找到行指针为3，去第三行找到数据行，比较fname是否为peter，以确保就是要查找的行。
		
		限制：1.哈希索引只包含哈希值和行指针。所以没有办法避免读取行，即只有根据行指针去内存中查找对应的数据行。
		      2.不是按照索引值来排序的，没办法用索引进行排序。
		      3.不支持部分索引列查找，因为要根据所有列来计算哈希值。
		      4.只支持等值比较的查询，因为范围查询无法精确计算哈希值
		      5.访问哈希索引数据的时候非常快吗，除非有很多哈希冲突
		      6.哈希冲突比较多的时候，一些索引的维护操作代价会很高。


	
	InnoDB自适应哈希索引：
			想要根据哪列来存储哈希索引，就额外增加一列来存储对该列的哈希值，可以用触发器来实现在插入时自动给该列进行赋值。只是查询的时候需要 and password=crc32('password');
		


	空间索引：MyISAM支持空间索引，可以用作地理数据存储。这类索引无须前缀查询，空间索引会从所有维度来索引数据。

	全文索引：查找的是文本的关键词，不是直接比较索引中的值。更类似于搜索引擎干的事，而不是简单的where条件匹配。


5.2索引的优点
	1.索引大大减少了服务器需要扫描的数据量
	2.索引可以帮助服务器避免排序和临时表。
	3.索引可以将随机I/O变成顺序I/O。


	索引不一定是最好的工具，对于较小的表来说，全表扫描成本更低，在较小的表上维护一个索引带来的开销大于索引带来的好处，所以需要辩证的看待索引的作用。
	对于TB级别的数据，定位单条记录的意义不大，经常使用块级别元数据技术来代替索引。

5.3高性能的索引策略

5.3.1独立的列
	指索引不能使表达式的一部分，也不能是函数的一部分。例如，select * from test where id+1 =5

5.3.2前缀索引和索引选择性
	有时需要索引很长的字符列，这样使索引变得大且慢，一个策略是自适应哈希索。有时自适应哈希索引还不够。
	通常可以索引开始的部分字符，这样可以大大的节约空间，但是索引的选择性会降低。索引的选择性是不重复的索引值和数据表记录总数的比值。

5.3.3多列索引
	三星索引：一星：索引将相关记录放到一起。二星：索引中的数据顺序和查找中的排列顺序一致。三星：如果索引的列包含查询中需要的全部列。
	
5.3.4选择合适的索引列顺序（B-Tree）
	索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。索引可以按照升序或者降序进行扫描。		
	当不考虑排序和分组时，将选择性最高的列放在前面通常是好的。

5.3.5聚簇索引（典型InnoDB）
	并不是一种单独的索引类型，而是一种数据存储方式。与普通索引的区别是，其他索引只存储索引的列和行指针   但是聚簇索引存储的是索引列和行数据，无法把数据行放到两个地方，所以一个表只能有一个聚簇索引。
	叶子页包含行的全部数据，但是节点页只包含了索引列


	聚集的优点：
		1.可以把相关数据保存在一起。
		2.数据访问更快。
		3，使用覆盖索引扫描的查询可以直接使用页节点中的主键值。
	聚集的缺点：
		1.聚簇数据最大限度地提高了I/O密集型应用的性能，如果数据全部放在内存中，则访问的顺序就没这么重要了，聚簇索引也就没有什么优势了。
		2.插入速度严重依赖插入顺序。按照主键的顺序进行插入最快。如果不是，最好在插入完成后进行optimize table重新组织一下表。
		3.更新聚簇索引列的代价很高，因为会强制InnoDB将每个更新的行移动到新位置
		4.基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题。（当一个新记录插入到一个已经存满的数据页中，后面的记录有可能移动到新的一页）
		5.聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏。或者由于分页导致数据不连续的时候。
		6.二级索引可能比想象的大，因为在二级索引的叶子结点包含了引用行的主键列。
		7.二级索引需要访问两次索引查找而不是一次。    因为二级索引保存的行指针（行指针为主键列），找到主键列后再去找对应的行数据。
	
	InnoDB和MyISAM数据分布的对比：
		MyISAM的索引保存的行指针是行号。InnoDB索引保存的行指针是主键。		
		MyISAM建议使用定长的列，因为MyISAM可以自动跳过行找到所需的行。
		
		
		InnoDB支持聚簇索引，所以所有行数据都是存储在索引中。聚簇索引的每个叶子结点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及剩余所有列。
		InnoDB的二级索引存储的不是行指针而是行的主键值，减少了当出现行移动或数据页分裂时二级索引的维护工作。
		

		在InnoDB表中按主键顺序插入行
			最好避免随机的（不连续且值得分布范围较大）的聚簇索引，例如将UUID作为索引
			使用UUID等作为主键不仅花费时间更长，而且索引占用的空间更大。一方面由于主键字段更长，一方面是由于页分裂和碎片导致的。
			使用InnoDB时应该尽可能地按照主键顺序插入数据，并且尽可能使用单调增加的聚簇键的值来插入新行。
		
		顺序的主键什么时候会造成更坏的结果？
			顺序插入的时候，主键的上界会成为热点。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁的竞争。

		
5.3.6覆盖索引
	如果一个索引包含所有查询字段的值，就是覆盖索引（也是索引的三星规则中第三星的规则）  不光是where中的，还有select后的

	覆盖索引的好处
		1.索引条目通常远小于数据行大小，如果只读取索引，可以极大减少数据访问量。索引比数据行更小，更容易全部放入内存中。
		2.索引按列值顺序存储，所以I/O密集型应用范围查询比随机从磁盘读取每一行数据I/O少得多。
		3.一些存储引擎，如MyISAM在内存中只缓存索引，数据则依赖操作系统缓存。所以读一次数据要一次系统调用，使用覆盖索引就减少了系统调用的开销。
		4.由于InnoDB的聚簇索引，覆盖索引对InnoDB特别有用。如果二级索引能覆盖查询，就避免了二级索引的二次查询。

	Memory存储引擎不支持覆盖索引。


	无法使用覆盖索引的原因：
		1.没有任何索引能够覆盖这个查询。
		2.mysql不能在索引中执行like操作。但是，当select的为主键时可以使用。

	延迟关联
		Join（select prod_id
			from products
			where actor='dsda' and title like '%sad%'）as t1 on(ti.prod_id=products.prod_id)

	对于InnoDB的二级索引来说，因为二级索引都带有主键列，所以可以认为即使二级索引没有显式声明主键列，也可以在带有主键的查询应用覆盖索引。


突发奇想的问题：
	为什么MyISAM的count函数执行很快，而InnoDB的count函数执行的很慢（和记录数有关）？
		因为MyISAM会记录记录数，而InnoDB没有记录记录数，而是实时统计。当有where条件的时候，就不是很快了。因为要根据条件查找后再进行统计。
		MyISAM存储引擎在统计列数的时候，如果知道列col不可能为空的时候，内部会把count(col)转化为count(*)






	


			
	









































	

		






















