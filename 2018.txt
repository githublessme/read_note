
									第一章 Mysql架构和历史
mysql服务器逻辑架构
	第一层：连接/线程处理（这是大多数基于网络的客服端/服务器的工具或服务都有的类似的架构）
	第二层：查询缓存-解析器
			   |
			优化器
		这是mysql的核心功能，包括查询、分析、优化、缓存以及所有的内置函数,所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图
	第三层：包括存储引擎。负责mysql中数据的存储和提取,服务器通过API和存储引擎进行通信，不同的存储引擎不会进行通信

mysql查询的步骤：
	0.先查询缓存，如果有相同的查询，则直接从缓存中取数据，否则从步骤1开始执行（仅限select操作）
	1.mysql解析查询
	2.创建内部数据结构（解析树）
	3.对其进行优化（优化器）
	4.执行查询
	(优化器并不关心表使用的是什么引擎,(透明))

并发控制：服务器层和存储引擎层
	两种锁机制：读锁和写锁（共享锁和排他锁）

锁粒度：
	尽量只锁定需要修改的部分，而不是所有资源，这样可以达到最良好的并发性。
	一般都是在表上施加行级锁

	表锁：mysql最基本的锁策略，锁资源的开销最少。  写锁比读锁具有更高的优先级。写锁可以在队列中插入到读锁前面。
	行级锁：最大程度支持并发，！！！！行级锁只在存储引擎层实现。服务器完全不了解存储引擎中的锁实现。
	
事务：ACID （A：原子性，C:一致性 I:隔离性 D:持久性）

隔离级别：
	READ UNCOMMIT 读未提交：可以读取其他事务中未提交的数据，可以引发脏读的发生。
	READ COMMIT   读已提交：大多数数据库系统默认的是这个级别的隔离，只能看到其他事务提交的修改。一个事务从开始到提交所做的事情对其他的事务是不可见的。这也叫不可重复读。
	REPEATABLE READ 可重复读：在事务进行时，向范围内插入了一条新数据，这个事务再读取这个范围的数据时就会出现幻行，也叫幻行。幻读
	SERIALIZABLE	串行化 ：在读取的每一行数据上加锁。这样锁开销太大，而且并发性不好，一般情况下不会用这种隔离级别。


死锁：
	事务1：
		请求Id为1的数据行
		请求Id为2的数据行
	事务2：
		请求Id为2的数据行
		请求Id为1的数据行
	当下面这两个事务同时开始，给第一行的数据加锁，然后执行第一步的操作，之后去请求第二步操作时，两个事务的第二步操作都被对方的事务加了锁，谁也不会请求到资源，所以产生了死锁。
	
	解决方案：InnoDB：将持有最少行级排他锁的事务进行回滚。
	锁的行为和顺序是存储引擎相关的。


事务日志：存储引擎在修改表的时候，只需要修改内存拷贝，再将修改行为写到事务日志中，而不用每次都将修改持久化到磁盘中。然后事务日志采用追加的方式，将修改持久化到磁盘中，
	  然后内存中被修改的数据再慢慢的刷到磁盘中去。


mysql中的事务：
	mysql的两种支持事务的存储引擎：InnoDB和NDB Cluster。
	自动提交：mysql默认 autocommit。
	在事务中混合使用存储引擎：
		这样在不出问题的时候没什么区别，但是如果出现问题需要回滚的时候，事务型的表将数据回滚，而非事务型的表无法将数据回滚，会造成数据不一致的情况。

多版本并发控制：
	大多数事务型的存储引擎不光是实现了行级锁，还实现了MVCC（多版本并发控制）
	InnoDB的MVCC：
		通过在每行记录后面添加两个隐藏的列来实现：行创建的时间，和过期时间。（都是存的版本号，而不是时间）
		select会根据以下两个条件检查每行记录：
			a.之查找版本号早于当前事务版本的数据行
			b.行的过期时间未定义或大于当前版本的（大于当前版本号，说明已经在当前事务进行过程中已经完成事务的数据行）
		insert
			为新插入的每一行保存当前系统版本号作为行创建时间
		delete
			为删除的行保存当前系统版本号作为过期时间。
		update
			InnoDB为插入一行新纪录，保存当前版本号作为行的创建时间，同时保存当前版本号作为原来的行的过期时间


mysql的存储引擎：
	不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在mysql服务层统一处理的。
	

	InnoDB：
		是mysql的默认事务型引擎，也是最重要，应用最广泛的存储引擎。   性能好，自动崩溃恢复特性。
		采用MVCC来支持高并发，其默认的隔离级别是REPEATABLE READ（可重复读）,用间隙锁来防止幻读的发生。
		基于聚簇索引建立的。
	MYISAM：
		不支持事务和行级锁。崩溃后无法安全恢复。
		不支持行级锁，对整张表加锁。
		MYISAM压缩表：
			表在导入数据后，不会再进行修改操作，可以采用MYISAM压缩表。减少磁盘占用，提升查询性能。支持索引，但是只读。
	Archive：
		只支持insert和select操作，缓存所有写操作，并通过zlib对插入的行进行压缩，比MYISAM I/O更少，但是select会查询全表。
		支持行级锁，在一个查询开始到返回所有存在的数据，其他的select会被阻塞。保证一致性的读。

	CSV：
		不支持索引，可以和excel数据相互转换，可以作为一种数据交换的机制。
	Federated：
		是访问其他mysql服务器的一个代理，会创建一个远程的链接，并将查询传输到远程的服务器上执行。然后提取或发送需要的数据。
	Memory：
		数据保存在内存中，不进行持久化操作，重启数据会丢失。但是要比MYISAM快一个数量级
		应用场景：
			用于查找或映射表，例如将邮编和州名映射的表
			用于缓存周期性聚合数据的结果。
			用于保存数据分析产生的中间数据。
		Memory支持hash索引，查找非常快。
		表级锁，并发写入性能较低。不支持BLOB和TEXT
		

选择存储引擎需要考虑的因素：
	1.事务：如果需要事务，则应该使用事务型存储引擎，如：InnoDB。如果不需要事务，只要是进行select insert 操作，MyISAM是不错的选择。
	2.备份：如果可以定期关闭服务器执行备份，则不需要考虑。如果需要在线热备份就应该选择InnoDB。
	3.崩溃恢复：如果需要良好的崩溃恢复功能，则选择InnoDB比较好。
	4.特有的特性：

	
	日志型应用：这种应用对插入速度有很高的要求，数据库不能成为瓶颈，这时候可以使用MYISAM或者Archive存储。
			但是如果需要对日志做分析，就会非常慢。这时候可以使用mysql内置的复制方案复制一份，然后在这个复制的表进行耗时比较高的查询操作。
	
	只读或者大部分情况下只读的表：
			读多写少的业务，不介意崩溃恢复的问题，可以选用MyISAM。但是不要小看崩溃恢复问题，最好选用InnoDB
	
	订单处理：肯定支持事务，选用InnoDB等事务型存储引擎。
	

转换表的存储引擎（三种方法）:
	alter table ： alter table mytable engine = InnoDB；
	导入与导出：先导出修改存储引擎后导入回去，导入前记得删掉旧表
	创建与查询：create table new_table like old_table；
		    alter table new_table engine = InnoDB；
		    insert into new_table select * from old_table;


										第四章Schema与数据类型优化
4.1选择优化的数据类型
	更小的通常更好：更小的通常更快
	简单就好：简单数据类型的操作通常需要更少的CPU周期
	尽量避免null，但是当后台处理非null数据吃力时，也没有必要非要避免null，要根据实际情况选择。
	

4.1.1整数类型
	UNSIGNED属性，表示不允许负值，可以使正数的上限提高一倍。

4.1.2实数类型
	实数是带小数的部分的数字，但是也可以使用DECIMAL存储比BIGINT还大的整数。
	
4.1.3字符串类型
	varchar用于存储可变长字符串，比定长更节省空间。varchar需要1到两个字节存储字符串长度。varchar节省了存储空间，所以对性能有帮助，但是行是变长的，在update时可能使行变得
	更长，这有可能需要额外的工作。
	
	varchar的适用情况：
		字符串列的最大长度比平均长度大得多。列的更新很少，所以碎片不是问题。使用了像UTF-8这样复杂的字符集，每个字符都适用不同的字节数进行存储。
	InnoDB把过长的varchar存储为BLOB
	
	char是固定长度的，总是为字符串分配足够的空间。会自动截断末尾的空格
	char的适用情况：
		存储很短的字符串。所有值都接近同一个长度。像是存储密码的MD5值，因为这是一个定长的值。对于非常短的列，用char更有优势，因为不用像varchar那样在末尾存储字符串长度。
	
	Memory只支持定长的行，即使有变长的字段，也会根据最大长度分配空间。

	最好只分配真正需要的空间，如果能用varchar（5）就不要用varchar（20）
	
	BLOB和TEXT类型：
		都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

		进行排序的方式跟其他字符串类型不同，是根据每列最前max_sort_length字节而不是整个字符串做排序。
		
		Memory引擎不支持BLOB和TEXT。

	使用枚举（ENUM）代替字符串类型
		create table enum_text(
			e enum('fish','dog','apple') NOT NULL
		);
		insert into enum_test(e) values ('fish'),('dog'),('apple');
	因为mysql在存储枚举类型的时候，会将数据压缩成一到两个字节。实际存储的是数字。排序方式是按照内部数字排序而不是字符串。
	枚举最不好的地方就是，字符串列表是固定的，添加和删除字符串必须使用alter table
	

4.1.4时间类型
	DATETIME和TIMESTAMP
	一般情况应该选择TIMESTAMP，因为它比DATETIME空间效率更高。

4.1.6选择标识符
	在存储标识符的时候（我理解为主键），不应该选择使用字符串类型，因为比较起来复杂，效率低。

	一些技巧：
		整数类型通常是最好的选择，他们很快并且可以使用AUTO_INCREMENT
		ENUM和SET通常是糟糕的选择，
		字符串类型，如果有可能，尽量避免使用字符串类型作为标识列，因为它们很耗空间，而且比数字类型慢。尤其是MyISAM存储引擎，默认对字符串进行压缩索引，导致查询很慢。
		对于完全随机的字符串，如md5，uuid等，新值会任意分布在很大的空间内。导致insert和select语句变得很慢。p126 等学差不多了回过来再看。
	