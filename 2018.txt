mysql服务器逻辑架构
	第一层：连接/线程处理（这是大多数基于网络的客服端/服务器的工具或服务都有的类似的架构）
	第二层：查询缓存-解析器
			   |
			优化器
		这是mysql的核心功能，包括查询、分析、优化、缓存以及所有的内置函数,所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图
	第三层：包括存储引擎。负责mysql中数据的存储和提取,服务器通过API和存储引擎进行通信，不同的存储引擎不会进行通信

mysql查询的步骤：
	0.先查询缓存，如果有相同的查询，则直接从缓存中取数据，否则从步骤1开始执行（仅限select操作）
	1.mysql解析查询
	2.创建内部数据结构（解析树）
	3.对其进行优化（优化器）
	4.执行查询
	(优化器并不关心表使用的是什么引擎,(透明))

并发控制：服务器层和存储引擎层
	两种锁机制：读锁和写锁（共享锁和排他锁）

锁粒度：
	尽量只锁定需要修改的部分，而不是所有资源，这样可以达到最良好的并发性。
	一般都是在表上施加行级锁

	表锁：mysql最基本的锁策略，锁资源的开销最少。  写锁比读锁具有更高的优先级。写锁可以在队列中插入到读锁前面。
	行级锁：最大程度支持并发，！！！！行级锁只在存储引擎层实现。服务器完全不了解存储引擎中的锁实现。
	
事务：ACID （A：原子性，C:一致性 I:隔离性 D:持久性）

隔离级别：
	READ UNCOMMIT 读未提交：可以读取其他事务中未提交的数据，可以引发脏读的发生。
	READ COMMIT   读已提交：大多数数据库系统默认的是这个级别的隔离，只能看到其他事务提交的修改。一个事务从开始到提交所做的事情对其他的事务是不可见的。这也叫不可重复读。
	REPEATABLE READ 可重复读：在事务进行时，向范围内插入了一条新数据，这个事务再读取这个范围的数据时就会出现幻行，也叫幻行。幻读
	SERIALIZABLE	串行化 ：在读取的每一行数据上加锁。这样锁开销太大，而且并发性不好，一般情况下不会用这种隔离级别。


死锁：
	事务1：
		请求Id为1的数据行
		请求Id为2的数据行
	事务2：
		请求Id为2的数据行
		请求Id为1的数据行
	当下面这两个事务同时开始，给第一行的数据加锁，然后执行第一步的操作，之后去请求第二步操作时，两个事务的第二步操作都被对方的事务加了锁，谁也不会请求到资源，所以产生了死锁。
	
	解决方案：InnoDB：将持有最少行级排他锁的事务进行回滚。
	锁的行为和顺序是存储引擎相关的。


事务日志：存储引擎在修改表的时候，只需要修改内存拷贝，再将修改行为写到事务日志中，而不用每次都将修改持久化到磁盘中。然后事务日志采用追加的方式，将修改持久化到磁盘中，
	  然后内存中被修改的数据再慢慢的刷到磁盘中去。


mysql中的事务：
	mysql的两种支持事务的存储引擎：InnoDB和NDB Cluster。
	自动提交：mysql默认 autocommit。
	在事务中混合使用存储引擎：
		这样在不出问题的时候没什么区别，但是如果出现问题需要回滚的时候，事务型的表将数据回滚，而非事务型的表无法将数据回滚，会造成数据不一致的情况。

多版本并发控制：
	大多数事务型的存储引擎不光是实现了行级锁，还实现了MVCC（多版本并发控制）
	InnoDB的MVCC：
		通过在每行记录后面添加两个隐藏的列来实现：行创建的时间，和过期时间。（都是存的版本号，而不是时间）
		select会根据以下两个条件检查每行记录：
			a.之查找版本号早于当前事务版本的数据行
			b.行的过期时间未定义或大于当前版本的（大于当前版本号，说明已经在当前事务进行过程中已经完成事务的数据行）
		insert
			为新插入的每一行保存当前系统版本号作为行创建时间
		delete
			为删除的行保存当前系统版本号作为过期时间。
		update
			InnoDB为插入一行新纪录，保存当前版本号作为行的创建时间，同时保存当前版本号作为原来的行的过期时间


mysql的存储引擎：
	不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在mysql服务层统一处理的。
	

	InnoDB：
		是mysql的默认事务型引擎，也是最重要，应用最广泛的存储引擎。   性能好，自动崩溃恢复特性。
		采用MVCC来支持高并发，其默认的隔离级别是REPEATABLE READ（可重复读）,用间隙锁来防止幻读的发生。
		基于聚簇索引建立的。
	MYISAM：
		不支持事务和行级锁。崩溃后无法安全恢复。
		不支持行级锁，对整张表加锁。
		MYISAM压缩表：
			表在导入数据后，不会再进行修改操作，可以采用MYISAM压缩表。减少磁盘占用，提升查询性能。支持索引，但是只读。
	Archive：
		只支持insert和select操作，缓存所有写操作，并通过zlib对插入的行进行压缩，比MYISAM I/O更少，但是select会查询全表。
		支持行级锁，在一个查询开始到返回所有存在的数据，其他的select会被阻塞。保证一致性的读。

	CSV：
		不支持索引，可以和excel数据相互转换，可以作为一种数据交换的机制。
	Federated：
		是访问其他mysql服务器的一个代理，会创建一个远程的链接，并将查询传输到远程的服务器上执行。然后提取或发送需要的数据。
	Memory：
		数据保存在内存中，不进行持久化操作，重启数据会丢失。但是要比MYISAM快一个数量级
		应用场景：
			用于查找或映射表，例如将邮编和州名映射的表
			用于缓存周期性聚合数据的结果。
			用于保存数据分析产生的中间数据。
		Memory支持hash索引，查找非常快。
		表级锁，并发写入性能较低。不支持BLOB和TEXT
		
