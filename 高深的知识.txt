java虚拟机运行时数据区：
	1.程序计数器：
		用来记录当前线程执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条要执行的字节码命令。

		java虚拟机的多线程是通过线程的轮流切换来实现的，所以每个线程都要记录自己线程对应的执行到的字节码行数，来确保当本线程取得了执行的权利之后可以从上次
		中断的位置继续执行。所以程序计数器是线程私有的，每个线程都有一个独立的程序计数器。
		
		注意：如果线程执行的是java方法则程序计数器存储的是字节码的行号，而如果执行的是native方法,则计数器为空。此内存区是唯一一个在java虚拟机规范中没有规定
		      任何OutOfMemoryError情况的区域。
	
	2.java虚拟机栈：
		和程序计数器一样也是线程私有的，生命周期和线程相同。每个方法执行的时候都会创建一个栈帧（stackFrame），用来储存局部变量表，操作栈、动态链接、方法出口
		等信息。每一个方法的调用直到执行结束就对应着栈帧在java虚拟机栈的从入栈到出栈的过程。

		现在许多程序员喜欢笼统的说堆栈，这其中的栈就是对应的java虚拟机栈中的局部变量表的部分。

		局部变量表存储着各种基本类型的变量（boolean，int，short，long，double，float，byte，char）和对象的引用类型（可能是对象地址的指针，也可能指向对象的句
		柄，和returnAdress类型（1.7之后好像没什么卵用了））。

		其中64位的double和long类型的数据会占用两个变量空间（slot），其他的都占用一个。局部变量表所需的空间在编译期间来分配（很关键），在运行期间不会改变局部
		变量表的大小。

		java虚拟机规范中，规定了这个区域的两种异常情况：
			1.如果线程请求的栈深度大于虚拟机所允许的深度，跑出StackOverflowError异常。
			2.如果虚拟机可以扩展，当扩展申请不到足够的内存，抛出OutOfMemoryError异常。

	
	3.本地方法栈：
		本地方法栈和java虚拟机方法栈功能类似，区别就是本地方法栈是为native方法服务的，而java虚拟机栈是为执行java方法（字节码）服务的。

	4.java堆：
		Java堆是线程共享的，在虚拟机启动的时候创建。此内存区域唯一的目的就是存放对象实例。

		java堆是垃圾收集器集中管理的主要区域。现在的收集器基本都采用分代回收算法，将堆分为年轻代和老年代（young generation and old generation）。再细致一点
		可以分成Eden空间、From Survivor空间和 To Survivor空间等。
		如果从内存分配的角度来看，java堆中还可能划分出多个线程私有的分配缓存区(Thread Local Allocation Buffer)

		主流的虚拟机都是可扩展的（通过-Xmx 和-Xms 控制），当java堆没有内存完成实例分配并且无法扩展，抛出OutOfMemoryError异常。

	5.方法区：
		和java堆一样是各个线程共享的内存区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

		有些在hotspot虚拟机的开发的开发者喜欢把方法区成为永久代（Permanent Generation），知识hotspot团队将GC扩展到方法区，对于其他虚拟机（BEA JRockit、IBM J9）
		是不存在方法区的概念的。

		垃圾回收的行为在这个区域还是比价少见的，但并非数据进入这个区域后，就如同这个区域的名字一样永久存在了。这个区域内存回收的目标主要是针对常量池的回收和类型
		卸载。

		当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

	6.运行时常量池：
		运行时常量池是方法区的一部分（1.7开始归到堆内存空间中），class文件除了类的版本、字段、方法、接口描述等信息外，还有一项信息是常量池，用于存放编译期生成的
		各种字面量和符号引用，这部分内容在类加载后存放到运行时常量池中。
		
		一般来说，除了保存class文件描述的符号引用外，还会把翻译出来的直接引用页存储在运行时常量池中。

		运行时常量池从相对class文件常量池的另一个特征是动态性，java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中，如：String的intern()方法

		当常量池无法申请到内存时会抛出OutOfMemoryError异常。

	7.直接内存：
		并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。但是这部分也被频繁的使用，也可能导致OutOfMemroyError异常。
		
		jdk1.4加入NIO（New Input/Output），引入了基于通道的与缓冲区的IO方式，使用Native函数库直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块
		内存的引用来进行操作。这样能显著提高性能，避免了在java堆和Native堆中来回复制数据。

		直接内存不受java堆的内存限制，但是收到计算机总内存大小及处理器寻址空间的限制

2.java中对象的创建过程：
	当虚拟机遇到一条new指令的时候，会按照以下步骤进行：
	1.检查这个指令的参数是否在常量池中定位到一个类的符号引用，并检查这个类是否被加载、解析、初始化过。如果没有则先加载对应类。
	2.为新生对象分配内存，具体分配多少内存请看下一个知识点
		2.1堆内存分配方式（两种）
			（1）指针碰撞：当堆内存是规整的时候，堆内存分为两部分，一部分是用过的区域，一部分是空间区域，两个区间中间有一个指针来进行分隔，确定好对象分配的内存
			               大小后，将指针向空闲区移动对应大小的距离（相当于空间区减少，用过区增加）
			（2）空闲列表：当堆内存不是规整的时候，已使用的空间和空闲区间相互交错，没办法简单的进行指针碰撞，虚拟机就必须维护一个列表，记录哪些内存块是可用的，
				       在为新生对象分配空间的时候，找到一个足够大的空间划分给它。并更新列表上的记录。

		2.2影响堆内存是否规整的因素：
			垃圾收集器是否带有压缩整理的功能来决定
			在使用Serial、ParNew等带Compact（复制，即采用复制算法的）过程的收集器，堆内存就是规整的，选择使用指针碰撞的方法分配内存
			在使用CMS这种基于Mark-Sweep算法（标记清除算法）的收集器时，堆内存不规整，使用空闲列表的方法来分配内存

		2.3分配内存会出现并发问题，解决方法（两种）：
			（1）对分配内存空间的动作进行同步处理-虚拟机采用CAS（compare and swap）配上失败重试的方式保证原子性。
			（2）把内存分配动作划分到不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，成为本地线程分配缓冲（Thread Local allocation Buffer，TLAB）。
			     哪个线程需要分配内存就在哪个线程的TLAB上分配，只有在TLAB用完并分配新的TLAB时，才需要同步锁定。

			PS:CAS是包含三个操作数：内存位置、预期原值、新值。如果内存位置上的值和预期原值一样，就将内存位置上的原值更新为新值，否则不更改。并返回现在这个位置
			   对应的值。如果失败一直进行CAS操作，直到成功。

	3.内存分配完成后，虚拟机将分配的内存空间都初始化为0值（不是初始化对象属性，而是内存空间初始化），不包含对象头。如果使用TLAB，这一工作也可以提前到TLAB分配时进行。
	  这一步保证了对象的实例字段如果不赋初值也能够直接使用，程序能访问到这些字段类型对应的零值，比如：boolean默认false，int默认0（对象的实例数据部分）

	4.虚拟机对对象进行必要设置（设置对象头，下面知识点会讲解对象头包含什么内容）

	上述步骤结束后，从虚拟机的视角看，对象创建完成，但是没有执行init操作。所有数据（对象的成员变量之类的）都还是零值，init方法就是按照程序员的意愿进行初始化，到此对象
	才算建立完毕。

3.对象的内存布局（三个区域：对象头、实例数据、对齐填充）
	1.对象头的构成（两部分）：
		（1）Mark Word：用于存储对象自身的运行时数据（如哈希码、GC分代年龄、锁状态标志，线程持有的锁、偏向线程ID、偏向时间戳等），这数据在32位和64位虚拟机分别为32
		     Bit和64bit。运行时数据很多，超出规定的32bit和64bit，mark word被设计成非固定数据结构（在状态不同时数据结构不同）以便存储尽量多的信息。
		     
			状态			标志位			存储内容

		      未锁定			01			对象哈希码、对象分代年龄
		      轻量级锁定		00			指向锁记录指针
		      膨胀（重量级锁定）	10			指向重量级锁指针
		      GC标记			11			空，不需要记录信息
		      可偏向			01			偏向线程ID、偏向时间戳、对象分代年龄

		（2）类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。并不是所有虚拟机必须在对象数据上保留类型指针，即查找对象的类元信
		     息不一定要经过对象本身（在栈中存储的该对象的引用包含句柄中存有对象类型数据的指针，这个存在对象头的是直接指针的引用方式，猜测）。

		另外，如果对象是数组，对象头还要有一块用来记录数组长度的数据，因为虚拟机可以通过对象元数据确定普通对象大小，但是数组的元数据中无法确定大小。

	2.实例数据：
		存储对象真正有效的信息，包括子类定义的，还是父类继承下来的。hotspot虚拟机默认把相同宽度的字段分配到一起 long/double int short/float byte/boolean 在这个基础
		上，父类的变量在子类的前面，如果compactFields参数为true，子类的数据也有可能出现在父类数据的间隙中。

	3.对齐填充：
		这部分不是必要的，没有特殊含义，只是占位符的作用，因为hotspot内存管理系统要求对象大小必须是8字节的整数倍，对象头正好是8字节的整数倍（1或2倍）。所以实例数据
		没有对齐的时候就会用对齐填充来补全。


4.对象的访问定位（句柄和直接指针）：
	为了使用对象，会在栈上存储一个对象的引用，去访问它，具体的访问方式和虚拟机相关，主流的方式有句柄和直接指针两种
	
	1.句柄
		使用句柄会在java堆中划分出一个句柄池，引用存对象的句柄地址，句柄包含对象实例数据地址和类型数据地址信息（此部分信息在方法区）。

	2.直接指针
		引用直接存对象在堆中的地址，对象地址中包含类型数据地址信息（这部分信息在方法区）

	句柄的优点：存储的是稳定的句柄地址，当对象移动时（垃圾回收对象移动很正常）不会改变引用，而只需要改变句柄中实例数据的地址即可。
	直接指针的优点：速度快，节省了一次指针定位需要的开销（没有实例数据地址）， hotspot采用这种方式。

5.

	
