java虚拟机运行时数据区：
	1.程序计数器：
		用来记录当前线程执行的字节码的行号指示器。字节码解释器通过改变这个计数器的值来选取下一条要执行的字节码命令。

		java虚拟机的多线程是通过线程的轮流切换来实现的，所以每个线程都要记录自己线程对应的执行到的字节码行数，来确保当本线程取得了执行的权利之后可以从上次
		中断的位置继续执行。所以程序计数器是线程私有的，每个线程都有一个独立的程序计数器。
		
		注意：如果线程执行的是java方法则程序计数器存储的是字节码的行号，而如果执行的是native方法,则计数器为空。此内存区是唯一一个在java虚拟机规范中没有规定
		      任何OutOfMemoryError情况的区域。
	
	2.java虚拟机栈：
		和程序计数器一样也是线程私有的，生命周期和线程相同。每个方法执行的时候都会创建一个栈帧（stackFrame），用来储存局部变量表，操作栈、动态链接、方法出口
		等信息。每一个方法的调用直到执行结束就对应着栈帧在java虚拟机栈的从入栈到出栈的过程。

		现在许多程序员喜欢笼统的说堆栈，这其中的栈就是对应的java虚拟机栈中的局部变量表的部分。

		局部变量表存储着各种基本类型的变量（boolean，int，short，long，double，float，byte，char）和对象的引用类型（可能是对象地址的指针，也可能指向对象的句
		柄，和returnAdress类型（1.7之后好像没什么卵用了））。

		其中64位的double和long类型的数据会占用两个变量空间（slot），其他的都占用一个。局部变量表所需的空间在编译期间来分配（很关键），在运行期间不会改变局部
		变量表的大小。

		java虚拟机规范中，规定了这个区域的两种异常情况：
			1.如果线程请求的栈深度大于虚拟机所允许的深度，跑出StackOverflowError异常。
			2.如果虚拟机可以扩展，当扩展申请不到足够的内存，抛出OutOfMemoryError异常。

	
	3.本地方法栈：
		本地方法栈和java虚拟机方法栈功能类似，区别就是本地方法栈是为native方法服务的，而java虚拟机栈是为执行java方法（字节码）服务的。

	4.java堆：
		Java堆是线程共享的，在虚拟机启动的时候创建。此内存区域唯一的目的就是存放对象实例。

		java堆是垃圾收集器集中管理的主要区域。现在的收集器基本都采用分代回收算法，将堆分为年轻代和老年代（young generation and old generation）。再细致一点
		可以分成Eden空间、From Survivor空间和 To Survivor空间等。
		如果从内存分配的角度来看，java堆中还可能划分出多个线程私有的分配缓存区(Thread Local Allocation Buffer)

		主流的虚拟机都是可扩展的（通过-Xmx 和-Xms 控制），当java堆没有内存完成实例分配并且无法扩展，抛出OutOfMemoryError异常。

	5.方法区：
		和java堆一样是各个线程共享的内存区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

		有些在hotspot虚拟机的开发的开发者喜欢把方法区成为永久代（Permanent Generation），知识hotspot团队将GC扩展到方法区，对于其他虚拟机（BEA JRockit、IBM J9）
		是不存在方法区的概念的。

		垃圾回收的行为在这个区域还是比价少见的，但并非数据进入这个区域后，就如同这个区域的名字一样永久存在了。这个区域内存回收的目标主要是针对常量池的回收和类型
		卸载。

		当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

	6.运行时常量池：
		运行时常量池是方法区的一部分（1.7开始归到堆内存空间中），class文件除了类的版本、字段、方法、接口描述等信息外，还有一项信息是常量池，用于存放编译期生成的
		各种字面量和符号引用，这部分内容在类加载后存放到运行时常量池中。
		
		一般来说，除了保存class文件描述的符号引用外，还会把翻译出来的直接引用页存储在运行时常量池中。

		运行时常量池从相对class文件常量池的另一个特征是动态性，java语言并不要求常量一定只能在编译期产生，运行期间也可能将新的常量放入池中，如：String的intern()方法

		当常量池无法申请到内存时会抛出OutOfMemoryError异常。

	7.直接内存：
		并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。但是这部分也被频繁的使用，也可能导致OutOfMemroyError异常。
		
		jdk1.4加入NIO（New Input/Output），引入了基于通道的与缓冲区的IO方式，使用Native函数库直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块
		内存的引用来进行操作。这样能显著提高性能，避免了在java堆和Native堆中来回复制数据。

		直接内存不受java堆的内存限制，但是收到计算机总内存大小及处理器寻址空间的限制

2.java中对象的创建过程：
	当虚拟机遇到一条new指令的时候，会按照以下步骤进行：
	1.检查这个指令的参数是否在常量池中定位到一个类的符号引用，并检查这个类是否被加载、解析、初始化过。如果没有则先加载对应类。
	2.为新生对象分配内存，具体分配多少内存请看下一个知识点
		2.1堆内存分配方式（两种）
			（1）指针碰撞：当堆内存是规整的时候，堆内存分为两部分，一部分是用过的区域，一部分是空间区域，两个区间中间有一个指针来进行分隔，确定好对象分配的内存
			               大小后，将指针向空闲区移动对应大小的距离（相当于空间区减少，用过区增加）
			（2）空闲列表：当堆内存不是规整的时候，已使用的空间和空闲区间相互交错，没办法简单的进行指针碰撞，虚拟机就必须维护一个列表，记录哪些内存块是可用的，
				       在为新生对象分配空间的时候，找到一个足够大的空间划分给它。并更新列表上的记录。

		2.2影响堆内存是否规整的因素：
			垃圾收集器是否带有压缩整理的功能来决定
			在使用Serial、ParNew等带Compact（复制，即采用复制算法的）过程的收集器，堆内存就是规整的，选择使用指针碰撞的方法分配内存
			在使用CMS这种基于Mark-Sweep算法（标记清除算法）的收集器时，堆内存不规整，使用空闲列表的方法来分配内存

		2.3分配内存会出现并发问题，解决方法（两种）：
			（1）对分配内存空间的动作进行同步处理-虚拟机采用CAS（compare and swap）配上失败重试的方式保证原子性。
			（2）把内存分配动作划分到不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，成为本地线程分配缓冲（Thread Local allocation Buffer，TLAB）。
			     哪个线程需要分配内存就在哪个线程的TLAB上分配，只有在TLAB用完并分配新的TLAB时，才需要同步锁定。

			PS:CAS是包含三个操作数：内存位置、预期原值、新值。如果内存位置上的值和预期原值一样，就将内存位置上的原值更新为新值，否则不更改。并返回现在这个位置
			   对应的值。如果失败一直进行CAS操作，直到成功。

	3.内存分配完成后，虚拟机将分配的内存空间都初始化为0值（不是初始化对象属性，而是内存空间初始化），不包含对象头。如果使用TLAB，这一工作也可以提前到TLAB分配时进行。
	  这一步保证了对象的实例字段如果不赋初值也能够直接使用，程序能访问到这些字段类型对应的零值，比如：boolean默认false，int默认0（对象的实例数据部分）

	4.虚拟机对对象进行必要设置（设置对象头，下面知识点会讲解对象头包含什么内容）

	上述步骤结束后，从虚拟机的视角看，对象创建完成，但是没有执行init操作。所有数据（对象的成员变量之类的）都还是零值，init方法就是按照程序员的意愿进行初始化，到此对象
	才算建立完毕。

3.对象的内存布局（三个区域：对象头、实例数据、对齐填充）
	1.对象头的构成（两部分）：
		（1）Mark Word：用于存储对象自身的运行时数据（如哈希码、GC分代年龄、锁状态标志，线程持有的锁、偏向线程ID、偏向时间戳等），这数据在32位和64位虚拟机分别为32
		     Bit和64bit。运行时数据很多，超出规定的32bit和64bit，mark word被设计成非固定数据结构（在状态不同时数据结构不同）以便存储尽量多的信息。
		     
			状态			标志位			存储内容

		      未锁定			01			对象哈希码、对象分代年龄
		      轻量级锁定		00			指向锁记录指针
		      膨胀（重量级锁定）	10			指向重量级锁指针
		      GC标记			11			空，不需要记录信息
		      可偏向			01			偏向线程ID、偏向时间戳、对象分代年龄

		（2）类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。并不是所有虚拟机必须在对象数据上保留类型指针，即查找对象的类元信
		     息不一定要经过对象本身（在栈中存储的该对象的引用包含句柄中存有对象类型数据的指针，这个存在对象头的是直接指针的引用方式，猜测）。

		另外，如果对象是数组，对象头还要有一块用来记录数组长度的数据，因为虚拟机可以通过对象元数据确定普通对象大小，但是数组的元数据中无法确定大小。

	2.实例数据：
		存储对象真正有效的信息，包括子类定义的，还是父类继承下来的。hotspot虚拟机默认把相同宽度的字段分配到一起 long/double int short/float byte/boolean 在这个基础
		上，父类的变量在子类的前面，如果compactFields参数为true，子类的数据也有可能出现在父类数据的间隙中。

	3.对齐填充：
		这部分不是必要的，没有特殊含义，只是占位符的作用，因为hotspot内存管理系统要求对象大小必须是8字节的整数倍，对象头正好是8字节的整数倍（1或2倍）。所以实例数据
		没有对齐的时候就会用对齐填充来补全。


4.对象的访问定位（句柄和直接指针）：
	为了使用对象，会在栈上存储一个对象的引用，去访问它，具体的访问方式和虚拟机相关，主流的方式有句柄和直接指针两种
	
	1.句柄
		使用句柄会在java堆中划分出一个句柄池，引用存对象的句柄地址，句柄包含对象实例数据地址和类型数据地址信息（此部分信息在方法区）。

	2.直接指针
		引用直接存对象在堆中的地址，对象地址中包含类型数据地址信息（这部分信息在方法区）

	句柄的优点：存储的是稳定的句柄地址，当对象移动时（垃圾回收对象移动很正常）不会改变引用，而只需要改变句柄中实例数据的地址即可。
	直接指针的优点：速度快，节省了一次指针定位需要的开销（没有实例数据地址）， hotspot采用这种方式。






									第三章垃圾收集器与内存分配策略


1.概述：
	程序计数器（寄存器）、虚拟机栈、本地方法栈3个区域随线程的死亡而死亡（因为是线程私有的）。
	java堆和方法区却不一样，只有在程序运行期间才能知道会创建哪些对象，这部分对象回收都是动态的。垃圾回收关注的就是这部分区域的内存。

2.引用计数器法：
	如果对象被引用，对象的计数器加一，当对象的计数器为零（即没有引用指向），对象就会被回收。
	目前还没有虚拟机使用这种算法回收内存，因为它无法解决对象循环引用的问题。即A引用B，B引用A，这样AB永远都有引用指向，不会被垃圾回收器回收。

3.可达性分析算法：
	从GCRoots开始遍历，寻找完整的引用链，如果找完，有没有引用的对象（即从GCRoots不可达），证明此对象是不可用的，会被认定为回收对象。

	GCRoots包括：
		1.虚拟机栈中引用的对象。
		2.方法区类静态属性引用的对象。
		3.方法区中常量引用的对象。
		4.本地方发展中JNI（Native方法）引用的对象。

4.引用的类型：
	1.强引用：只要强引用还存在，垃圾收集器就永远不会回收。
	2.软引用：有用但非必须的对象，当内存不够的时候要发生OOM异常的时候，垃圾收集器就会将这些对象列进回收范围进行回收，如果内存还不够再抛出OOM异常。
	3.弱引用：非必需的对象，只能生存到下一次垃圾收集之前，如果发生垃圾收集，弱引用对象一定会被回收。
	4.虚引用：虚引用不会对对象有任何影响，无法通过虚引用取得对象实例，唯一的目的就是在被垃圾收集的时候收到一个系统通知。

5.finalize方法：
	不管对象自我拯救多少次（即在finalize方法中将自己赋给其他引用），finalize方式只能执行一次（即只能自我拯救一次）。
	如果虚拟机判定对象有必要执行finalize方法（没必要是指已经执行过finalize方法或者对象没覆盖finalize方法）。就会将对象放入F-queue队列中，并由虚拟机自动建立的、低
	优先级的finalizer线程去执行它，（执行是指会触发这个方法，但不一定保证等待方法执行结束，因为防止finalize方法中出现耗时长或者死循环的情况）。

6.回收方法区：
	永久代的垃圾收集主要分两部分内容：废弃常量和无用的类（常量和类型的卸载）。
	废弃常量比较好判断，但是无用的类就不好判断，要满足以下三个条件：
		1.该类的所有实例都已经被回收（因为堆中存储对象，包含类信息，需要用到）
		2.ClassLoader已经被回收
		3.该类的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类方法。

7.垃圾收集算法：
	1.标记-清除算法：
		最基础的垃圾收集算法，分为标记和清除两个阶段，先标记需要回收的对象，然后清除被标记的对象
		缺点：导致大量的空间碎片，当有较大对象存储进来的情况，无法分配足够大的连续空间而不得不提前触发一次垃圾回收，效率低。
		使用该算法的垃圾收集器：
	2.复制算法：
		现在新生代常用的垃圾收集算法，将内存分为大小相等的两个区域（改进后，分为Eden区和两个Survivor区），当其中一块区域内存用完，无法放下要进来的对象时，就会将
		这个区域的对象逐一复制到另外一块区域中去，然后清除这块区域的内存。

		现在商业虚拟机都采用这种算法来回收新生代。并且将新生代分为Eden区和两个Survivor区（默认比例8:1:1），当新建对象时，都存在Eden区，如果满了触发minorGC，使用
		复制算法将回收后剩下的对象放到Survivor1中，等Eden又满了，回收Eden和Survivor1中的对象，放到Survivor2中。循环如此。
		
		Eden和Survivor对象为811比例是因为大部分新生对象都是朝生夕死的，98%的对象都会被回收，如果按照标准复制算法一半一半的分区会造成浪费，所以Survivor区很小，但是
		不是所有情况都会是回收后剩下10%不到的对象，如果超出了Survivor大小，那么需要依赖其他内存区域（老年代）的分配担保机制。

		分配担保：如果上一次垃圾收集后的对象不够放入Survivor区域中，那么这些对象会直接放入老年代。

	3.标记-整理算法：
		复制算法在存活对象较多的时候就会进行较多的复制操作，效率很低（所以只有新生代采用复制算法，因为对象存活率很低，一般98%的对象活不过下一次垃圾收集）。
		所以像是老年代这种对象存活率较高的区域就不会选择这种算法。

		先是标记，然后所有存活的内存都向一端移动，然后将剩余内存末端后面的内存全部清除。

	4.分代收集算法：
		将内存区域划分为几块按年龄区分的空间，如新生代和老年代。然后根据各个区域的年龄特点选择适合的垃圾收集算法，如新生代采用复制算法，老年代没有分配担保，所以
		必须选择标记-清除或者标记-整理（这里老年代选用的是标记-整理）。

8.枚举根节点（可达性分析）
	可作为GCRoots的节点主要在全局性的引用和执行上下文，现在很多应用方法区就数百兆，逐个检查引用会消耗很多时间。
	另外，可达性分析对时间的敏感还体现在GC停顿上，因为如果在进行可达性分析的时候，对象的引用关系不能发生变化，这就导致在进行GC的时候必须停顿所有的java线程。sun将这个
	称为Stop The World。

	目前主流的java虚拟机使用的是准确式GC，当系统停顿下来后，不需要一个不漏的检查所有执行上下文和全局引用位置，虚拟机有办法直接知道哪些地方存着对象引用。（通过MopMap实现）

	OopMap，在类加载的时候，HotSpot就会把对象内存上什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。


9.安全点：
	1.在OopMap的协助下，HotSpot可以快速完成GCRoots枚举，但是能够引起对象引用关系变化的操作很多，不可能为每一个操作都生成一个OopMap，那样需要很多空间来存储。
	只是在特定指令的时候记录OopMap，这些位置称为安全点。即程序不是在所有时候都能停顿，只有到达了安全点才能停顿。

	安全点既不能选太多，这样频繁GC会导致运行负荷变大，也不能选的太少，这样会导致让GC等待太长时间。

	每个程序指令的执行都很短暂，没有办法定为安全点。安全点选定是以能让程序长时间执行的标准来选定的。所以指令序列的复用（方法调用，循环跳转，异常跳转）的时候为安全点。
		
	2.还有一个需要考虑的问题是何如在GC发生时让所有线程都跑到安全点才停下来。有两种方案：
		（1）抢先式中断：不需要线程的执行代码主动配合，当GC发生时，所有线程全都停顿，然后如果哪个线程没到安全点，再放开让它跑到安全点。
		（2）主动式中断：设置一个全局的标志（例如isNeedStop，当需要停顿的时候isNeedStop设为true，否则false），然后每个线程在安全点附近会有一个轮询标志，只要到轮询
				 标志这里就去访问全局标志（isNeedStop)，当需要停顿则停顿下来。（注意线程的执行方式是抢执行机会的，切换着执行）。

10.安全区域：
	当线程被挂起，没有被分配CPU时间来执行（如sleep或blocked）线程无法响应JVM的中断请求，显然JVM也不能等到线程分配到CPU时间，这时就需要安全区域的概念。
	安全区域即线程中一段时间内对象的引用关系不会发生变化，但线程进入这个区域标志自身为安全区域中，当开始GC就不用管身处安全区域的线程了。用户线程和垃圾回收线程可以并发，
	当GC正在进行中，用户线程要出安全区域前先确定GC是否结束，如果结束了直接可以出来把身处安全区域的标志去掉，如果GC正在进行则停顿等待GC结束。

11.垃圾收集器：
	并行：多个垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
	并发：用户线程和垃圾收集线程同时执行（但并不一定是并行的，可能会交替执行），用户线程在继续运行，而垃圾收集线程在另外一个CPU上运行。
	1.serial收集器（jdk1.3）：
		单线程收集器，只会使用一个CPU或一个收集线程去完成垃圾收集工作，而且当它进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束（stop the world）。
		它是运行在client模式下默认的新生代收集器。
		没有safeRegion只有safePoint，因为无法发。
		优点：简单高效，没有和其他线程交互的开销。

	2.ParNew收集器（jdk1.4）：
		简单说，就是Serial多线程版。（并行）
		在server模式下默认的新生代收集器。
		除了Serial收集器外，只有它可以和CMS收集器配合工作。在选择CMS收集器，默认新生代收集器为ParNew。
		在单核cpu上不会有超过Serial的性能，但是当cpu数量逐渐增多，ParNew的效果越来越好。

	3.Parallel Scavenge收集器（jdk1.4）：
		几乎和ParNew差不多。
	
	
	

	
